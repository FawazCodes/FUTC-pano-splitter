<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Pano Slicer Pro">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f172a">
    <title>Pano Slicer Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap');

        :root {
    --font-sans: ui-sans-serif, system-ui, -apple-system, 'Inter', 'Segoe UI', Roboto, sans-serif;
    
    /* Glass effects */
            --glass-bg: rgba(255, 255, 255, 0.08);
            --glass-secondary: rgba(255, 255, 255, 0.04);
            --glass-fallback: rgba(15, 23, 42, 0.85);
            --glass-border: rgba(255, 255, 255, 0.12);
            --glass-border-strong: rgba(255, 255, 255, 0.18);
            --glass-highlight: rgba(255, 255, 255, 0.25);
            --glass-shadow: rgba(0, 0, 0, 0.15);
            --glass-shadow-strong: rgba(0, 0, 0, 0.25);
    
    /* Gradients */
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    
    /* Radii and blurs */
    --radius-xl: 1.75rem; /* 28px */
    --radius-lg: 1.25rem; /* 20px */
    --radius-md: 1rem;    /* 16px */
    --radius-sm: 0.5rem;  /* New: 8px */
            --blur-strong: 24px;
            --blur-medium: 16px;
            --blur-light: 8px;
    
    /* Enhancements */
            --sat: 1.2;
            --contrast: 1.05;
    
    /* Mouse positions (set via JS) */
            --mx: 50%;
            --my: 50%;
            
    /* Dark theme colors */
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --bg-body: #0f172a;
            --bg-aurora-1: rgba(102, 126, 234, 0.15);
            --bg-aurora-2: rgba(118, 75, 162, 0.12);
            --bg-aurora-3: rgba(59, 130, 246, 0.08);
            --bg-aurora-4: rgba(168, 85, 247, 0.1);
    
    /* Error and success colors */
    --color-error: #ef4444;
    --color-success: #22c55e;
    --color-info: #3b82f6;
    
    /* Transitions */
    --transition-fast: 200ms ease;
    --transition-medium: 300ms cubic-bezier(0.4, 0, 0.2, 1);
    --transition-slow: 400ms cubic-bezier(0.4, 0, 0.2, 1);
    
    /* Shadows */
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.05);
    --shadow-md: 0 4px 12px var(--glass-shadow);
    --shadow-lg: 0 8px 24px var(--glass-shadow-strong);
    --shadow-xl: 0 20px 50px var(--glass-shadow-strong);
    --shadow-inset: inset 0 1px 0 rgba(255, 255, 255, 0.3);
}

        [data-theme="light"] {
    --glass-bg: rgba(255, 255, 255, 0.7);
    --glass-secondary: rgba(248, 250, 252, 0.8);
    --glass-fallback: rgba(248, 250, 252, 0.95);
            --glass-border: rgba(100, 116, 139, 0.2);
            --glass-border-strong: rgba(100, 116, 139, 0.3);
            --glass-highlight: rgba(15, 23, 42, 0.1);
            --glass-shadow: rgba(0, 0, 0, 0.08);
            --glass-shadow-strong: rgba(0, 0, 0, 0.12);
            --primary-gradient: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            
            --text-primary: #0f172a;
    --text-secondary: #334155;
    --text-muted: #475569;
            
            --bg-body: #f1f5f9;
            --bg-aurora-1: rgba(59, 130, 246, 0.08);
            --bg-aurora-2: rgba(139, 92, 246, 0.06);
            --bg-aurora-3: rgba(16, 185, 129, 0.05);
            --bg-aurora-4: rgba(245, 158, 11, 0.07);
    
    --color-error: #dc2626;
    --color-success: #16a34a;
    --color-info: #2563eb;
    
    --shadow-inset: inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        body {
    font-family: var(--font-sans);
            background:
                radial-gradient(1400px 900px at var(--aurora-1-x, 20%) var(--aurora-1-y, 15%), var(--bg-aurora-1) 0%, transparent 55%),
                radial-gradient(1000px 700px at var(--aurora-2-x, 80%) var(--aurora-2-y, 25%), var(--bg-aurora-2) 0%, transparent 55%),
                radial-gradient(800px 600px at var(--aurora-3-x, 60%) var(--aurora-3-y, 85%), var(--bg-aurora-3) 0%, transparent 60%),
                radial-gradient(1200px 800px at var(--aurora-4-x, 10%) var(--aurora-4-y, 90%), var(--bg-aurora-4) 0%, transparent 65%),
                var(--bg-body);
            min-height: 100vh;
            color: var(--text-primary);
    transition: color var(--transition-medium), background var(--transition-medium);
    margin: 0;
    padding: 0;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
        }

        .glass-card {
            position: relative;
            background: var(--glass-bg);
    border-radius: var(--radius-xl);
            border: 1px solid var(--glass-border-strong);
    box-shadow: var(--shadow-lg);
            overflow: hidden;
    transition: transform var(--transition-medium), box-shadow var(--transition-medium);
    will-change: transform, box-shadow;
}

/* no-op: removed backdrop filter fallback */

        .glass-card::after {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: conic-gradient(
                from 180deg at 50% 50%,
                transparent 0deg,
                var(--glass-highlight) 60deg,
                transparent 120deg,
                rgba(255, 255, 255, 0.15) 180deg,
                transparent 240deg,
                rgba(255, 255, 255, 0.2) 300deg,
                transparent 360deg
            );
            mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            mask-composite: xor;
            padding: 1px;
            opacity: 0.6;
            mix-blend-mode: screen;
    pointer-events: none;
        }

        .glass-sheen {
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: radial-gradient(
                300px 200px at var(--mx) var(--my),
                rgba(255, 255, 255, 0.2),
                rgba(255, 255, 255, 0.08) 40%,
                transparent 70%
            );
            mix-blend-mode: screen;
            opacity: 0;
    transition: opacity var(--transition-fast);
    pointer-events: none;
        }

        .glass-card:hover .glass-sheen {
            opacity: 1;
        }

        .glass-card:hover {
            transform: translateY(-4px);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 32px 80px var(--glass-shadow-strong), 0 12px 48px rgba(0, 0, 0, 0.15);
        }

        .card-header {
            position: relative;
            padding: 1.5rem;
            border-bottom: 1px solid var(--glass-border);
            font-size: 1.125rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--glass-secondary);
        }

        .card-header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4) 50%, transparent);
}

/* Make gradient title look good in light mode too */
[data-theme="light"] .gradient-title {
    background: linear-gradient(135deg, #2563eb, #8b5cf6 40%, #ec4899 100%);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
        }

        .action-button {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.875rem 1.75rem;
            border-radius: var(--radius-lg);
            font-weight: 600;
    color: #fff;
            background: var(--primary-gradient);
            border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: var(--shadow-inset), 0 8px 24px rgba(102, 126, 234, 0.25), var(--shadow-md);
    transition: all var(--transition-medium);
            overflow: hidden;
    cursor: pointer;
        }

        .action-button::before {
            content: "";
            position: absolute;
            inset: 0;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 50%, transparent 100%);
            opacity: 0;
    transition: opacity var(--transition-fast);
        }

        .action-button:hover::before {
            opacity: 1;
        }

        .action-button:hover {
            transform: translateY(-3px) scale(1.02);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 16px 40px rgba(102, 126, 234, 0.35), var(--shadow-lg);
        }

        .action-button:active {
    transform: translateY(1px) scale(0.98);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(102, 126, 234, 0.3);
    filter: brightness(0.9);
        }

        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--glass-secondary);
            border-color: var(--glass-border);
            box-shadow: none;
            transform: none;
        }

        .secondary-button {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.875rem 1.75rem;
            border-radius: var(--radius-lg);
            font-weight: 600;
            color: rgba(248, 250, 252, 0.9);
            background: var(--glass-secondary);
            border: 1px solid var(--glass-border);
    box-shadow: var(--shadow-sm);
    transition: all var(--transition-medium);
            overflow: hidden;
    cursor: pointer;
        }

        .secondary-button::before {
            content: "";
            position: absolute;
            inset: 0;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.02) 50%, transparent 100%);
            opacity: 0;
    transition: opacity var(--transition-fast);
        }

        .secondary-button:hover::before {
            opacity: 1;
        }

        .secondary-button:hover {
            transform: translateY(-2px);
            background: var(--glass-bg);
            border-color: var(--glass-border-strong);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.15), var(--shadow-lg);
}

.secondary-button:active {
    transform: translateY(1px) scale(0.98);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), var(--shadow-sm);
        }

        .info-box {
            background: var(--glass-secondary);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: 0.875rem 1.125rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
    box-shadow: var(--shadow-sm);
    font-size: 0.875rem;
    color: var(--text-muted);
}

.info-box strong {
    font-weight: 700;
    font-size: 1.25rem;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    color: #a5b4fc;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    letter-spacing: 0.025em;
    display: block;
    margin-top: 0.125rem;
}

[data-theme="light"] .info-box {
    color: var(--text-secondary);
}

[data-theme="light"] .info-box strong {
    color: #4f46e5;
    text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
}

        .switch {
          position: relative;
          display: inline-block;
          width: 52px;
          height: 28px;
        }

        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
    inset: 0;
          background-color: #334155;
    transition: var(--transition-medium);
          border-radius: 28px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 20px;
          width: 20px;
          left: 4px;
          bottom: 4px;
    background-color: #fff;
    transition: var(--transition-medium);
          border-radius: 50%;
        }

        input:checked + .slider {
    background: var(--primary-gradient);
        }

        input:checked + .slider:before {
          transform: translateX(24px);
        }

        .loader {
    border: 4px solid #334155;
    border-top: 4px solid #818cf8;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }

        .btn-loader {
            width: 20px;
            height: 20px;
    border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

/* Ensure loading overlay becomes visible when active */
#loading-overlay.active {
    opacity: 1;
    pointer-events: auto;
}

        .slice-item {
            position: relative;
            overflow: hidden;
    border-radius: var(--radius-sm);
            background-color: #1e293b;
            border: 1px solid #334155;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
    transition: transform var(--transition-medium), box-shadow var(--transition-medium);
        }

        .slice-item:hover {
            transform: scale(1.05);
    box-shadow: 0 8px 48px rgba(0, 0, 0, 0.6);
            z-index: 10;
        }

        .slice-item img {
            display: block;
            width: 100%;
            height: auto;
        }

        .slice-number {
            position: absolute;
            top: 8px;
            left: 8px;
            background-color: rgba(15, 23, 42, 0.8);
    color: #fff;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.875rem;
    border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .resolution {
            position: absolute;
            bottom: 4px;
            right: 8px;
            background-color: rgba(15, 23, 42, 0.8);
            color: #94a3b8;
            padding: 2px 6px;
    border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-family: monospace;
        }

        .full-view-item .slice-label {
            position: absolute;
            top: 8px;
            left: 8px;
    background: var(--primary-gradient);
    color: #fff;
            padding: 4px 10px;
            border-radius: 9999px;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        #upload-area.drag-over > div {
    border-color: #818cf8;
            background-color: rgba(99, 102, 241, 0.1);
        }
        
        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #475569;
    transition: all var(--transition-fast);
        }

.color-swatch:hover,
.color-swatch.active {
            transform: scale(1.1);
            border-color: #a5b4fc;
        }

        input[type="color"] {
            appearance: none;
            width: 44px;
            height: 44px;
            border: none;
            background: none;
            padding: 0;
            border-radius: 50%;
            overflow: hidden;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid #475569;
            border-radius: 50%;
        }

        .radio-group input[type="radio"] {
            appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid #475569;
            border-radius: 50%;
            background-color: transparent;
            position: relative;
            cursor: pointer;
    transition: all var(--transition-fast);
        }

        .radio-group input[type="radio"]:checked {
            border-color: #667eea;
    background: var(--primary-gradient);
        }

        .radio-group input[type="radio"]:checked::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
    background-color: #fff;
        }

        .radio-group label {
            font-weight: 500;
    color: var(--text-secondary);
            cursor: pointer;
    transition: color var(--transition-fast);
        }

        .radio-group label:hover {
            color: #e2e8f0;
        }

        .custom-range {
            appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #334155;
            outline: none;
    transition: background var(--transition-medium);
        }

        .custom-range::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
    background: var(--primary-gradient);
            cursor: pointer;
    box-shadow: var(--shadow-md);
    transition: all var(--transition-fast);
        }

        .custom-range::-webkit-slider-thumb:hover {
            transform: scale(1.1);
    box-shadow: var(--shadow-lg);
        }

        .custom-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
    background: var(--primary-gradient);
            cursor: pointer;
            border: none;
    box-shadow: var(--shadow-md);
    transition: all var(--transition-fast);
        }

        .custom-range::-moz-range-thumb:hover {
            transform: scale(1.1);
    box-shadow: var(--shadow-lg);
        }

.range-value-chip {
    position: absolute;
    transform: translate(-50%, -140%);
    background: rgba(15, 23, 42, 0.9);
    color: #fff;
    padding: 4px 8px;
    border-radius: 9999px;
    font-size: 12px;
    pointer-events: none;
    white-space: nowrap;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
    z-index: 5;
}

[data-theme="light"] .range-value-chip {
    background: rgba(15, 23, 42, 0.85);
    color: #fff;
}

        .progress-container {
            position: relative;
            width: 100%;
            height: 8px;
            background: var(--glass-secondary);
            border-radius: 4px;
            overflow: hidden;
            backdrop-filter: blur(var(--blur-light));
            border: 1px solid var(--glass-border);
        }

        .progress-bar {
            height: 100%;
            background: var(--primary-gradient);
            border-radius: 4px;
    transition: width var(--transition-medium);
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: "";
            position: absolute;
    inset: 0;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .skeleton {
    background: linear-gradient(90deg, var(--glass-secondary) 25%, var(--glass-bg) 50%, var(--glass-secondary) 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: var(--radius-md);
        }

        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .success-checkmark {
            width: 60px;
            height: 60px;
            border-radius: 50%;
    background: linear-gradient(135deg, var(--color-success), #059669);
            display: flex;
            align-items: center;
            justify-content: center;
            animation: successPop 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes successPop {
    0% { transform: scale(0) rotate(36deg); opacity: 0; }
    100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .checkmark-path {
            stroke-dasharray: 48;
            stroke-dashoffset: 48;
            animation: checkmarkDraw 0.5s ease-in-out 0.2s forwards;
        }

        @keyframes checkmarkDraw {
    to { stroke-dashoffset: 0; }
        }

        .collapsible-section {
    transition: all var(--transition-medium);
        }

        .collapsible-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            background: var(--glass-secondary);
            border-bottom: 1px solid var(--glass-border);
    transition: background var(--transition-fast);
        }

        .collapsible-header:hover {
            background: var(--glass-bg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
    transition: max-height var(--transition-medium);
        }

/* Expanded max-height handled via JS; no empty CSS ruleset required */

        .expand-icon {
    transition: transform var(--transition-medium);
        }

        .expand-icon.expanded {
            transform: rotate(180deg);
        }

        .touch-target {
            min-height: 48px;
            min-width: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-preview {
            position: relative;
            max-width: 200px;
    margin: 0.5rem auto;
            border-radius: var(--radius-lg);
            overflow: hidden;
            opacity: 0;
            transform: translateY(20px);
    transition: all var(--transition-slow);
        }

        .upload-preview.show {
            opacity: 1;
            transform: translateY(0);
        }

        .upload-preview img {
            width: 100%;
            height: auto;
            display: block;
        }

        .swipe-indicator {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--blur-medium));
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.8);
            animation: swipePulse 2s infinite;
        }

        @keyframes swipePulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .bottom-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-bottom: none;
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
            transform: translateY(100%);
    transition: transform var(--transition-slow);
            z-index: 1000;
    max-height: 85vh;
            overflow-y: auto;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 -8px 32px rgba(0, 0, 0, 0.3);
    will-change: transform;
        }

        .bottom-sheet.open {
            transform: translateY(0);
        }

        .bottom-sheet-handle {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
    margin: 1rem auto;
    cursor: pointer;
}

.bottom-sheet-content {
    padding: 0 1.5rem 2rem;
}

.bottom-sheet-section {
    margin-bottom: 2rem;
}

.bottom-sheet-section h3 {
    font-size: 1.125rem;
    font-weight: 600;
    color: rgba(248, 250, 252, 0.9);
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.bottom-sheet-section h3 svg {
    width: 20px;
    height: 20px;
        }

        .bottom-sheet-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            opacity: 0;
    transition: opacity var(--transition-slow);
            z-index: 999;
            pointer-events: none;
        }

        .bottom-sheet-backdrop.open {
            opacity: 1;
            pointer-events: auto;
        }

        #video-settings select,
        #video-settings input[type="number"] {
    background: var(--glass-secondary);
    border: 1px solid var(--glass-border);
            backdrop-filter: blur(var(--blur-light)) saturate(1.1);
            border-radius: var(--radius-md);
            color: rgba(248, 250, 252, 0.95);
            font-weight: 500;
    transition: all var(--transition-fast);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08), var(--shadow-sm);
        }

        #video-settings select:focus,
        #video-settings input[type="number"]:focus {
            border-color: var(--glass-border-strong);
            background: var(--glass-bg);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12), 0 0 0 3px rgba(102, 126, 234, 0.15), var(--shadow-md);
        }

        #video-settings select:hover,
        #video-settings input[type="number"]:hover {
            border-color: var(--glass-border-strong);
            background: var(--glass-bg);
        }

        #video-settings select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23cbd5e1' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.75rem center;
            background-repeat: no-repeat;
    background-size: 1.25rem;
            padding-right: 2.5rem;
        }

        #video-settings select:focus {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23667eea' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        }

        .mobile-fab {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 64px;
            height: 64px;
            background: var(--primary-gradient);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
    box-shadow: var(--shadow-inset), 0 8px 32px rgba(102, 126, 234, 0.4), var(--shadow-md);
            cursor: pointer;
            z-index: 1001;
    transition: all var(--transition-medium);
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-fab:hover {
            transform: scale(1.1);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 12px 48px rgba(102, 126, 234, 0.5), var(--shadow-lg);
        }

        .mobile-fab:active {
    transform: scale(0.92);
    box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3), var(--shadow-md);
        }

        .mobile-fab svg {
            width: 28px;
            height: 28px;
    color: #fff;
    transition: transform var(--transition-medium);
        }

        .mobile-fab.open svg {
            transform: rotate(45deg);
        }

        .lightbox {
            position: fixed;
            inset: 0;
    background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
    transition: opacity var(--transition-medium);
        }

        .lightbox.open {
            display: flex;
            opacity: 1;
        }

        .lightbox-content {
            position: relative;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lightbox-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: var(--radius-lg);
    box-shadow: 0 25px 80px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.1);
    transition: transform var(--transition-medium);
        }

        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
    background: var(--glass-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
    transition: all var(--transition-fast);
            color: rgba(255, 255, 255, 0.8);
            z-index: 2001;
        }

        .lightbox-nav:hover {
            background: var(--glass-secondary);
            border-color: var(--glass-border-strong);
    color: #fff;
            transform: translateY(-50%) scale(1.1);
        }

        .lightbox-nav:active {
    transform: translateY(-50%) scale(0.9);
        }

        .lightbox-nav.prev {
            left: 2rem;
        }

        .lightbox-nav.next {
            right: 2rem;
        }

        .lightbox-nav svg {
            width: 20px;
            height: 20px;
        }

        .lightbox-close {
            position: absolute;
            top: 2rem;
            right: 2rem;
    background: var(--glass-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
    transition: all var(--transition-fast);
            color: rgba(255, 255, 255, 0.8);
            z-index: 2001;
        }

        .lightbox-close:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
    color: #ef4444;
            transform: scale(1.1);
        }

        .lightbox-close svg {
            width: 24px;
            height: 24px;
        }

        .lightbox-info {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
    background: var(--glass-secondary);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-lg);
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.875rem;
            z-index: 2001;
        }

        .lightbox-download {
            background: var(--primary-gradient);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-md);
            padding: 0.5rem 1rem;
    color: #fff;
            font-weight: 500;
            cursor: pointer;
    transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
        }

        .lightbox-download:hover {
            transform: translateY(-1px);
    box-shadow: var(--shadow-inset), var(--shadow-lg);
}

.lightbox-download:active {
    transform: translateY(1px) scale(0.95);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2), var(--shadow-md);
        }

        .lightbox-download svg {
            width: 16px;
            height: 16px;
        }

        .radio-group input[type="radio"]:checked + label,
        .radio-group label:has(input[type="radio"]:checked) {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .radio-group label {
    transition: all var(--transition-fast);
            padding: 0.5rem 0.75rem;
    border: 1px solid rgba(148, 163, 184, 0.4);
            border-radius: var(--radius-md);
            cursor: pointer;
        }

        .radio-group label:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        [data-theme="light"] input[type="text"],
        [data-theme="light"] select,
[data-theme="light"] input[type="color"],
[data-theme="light"] input[type="number"],
[data-theme="light"] input[type="range"] {
    background: #ffffff;
            border-color: rgba(100, 116, 139, 0.3);
            color: var(--text-primary);
        }

        [data-theme="light"] input[type="text"]:focus,
        [data-theme="light"] select:focus,
        [data-theme="light"] input[type="color"]:focus {
            border-color: #3b82f6;
    background: #ffffff;
        }

        *:focus {
            outline: none;
        }
        
        .action-button:focus,
        .secondary-button:focus,
        button:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
    box-shadow: var(--shadow-inset), 0 0 0 3px rgba(102, 126, 234, 0.15), var(--shadow-lg);
            transform: translateY(-1px);
        }
        
        input[type="text"]:focus,
        input[type="file"]:focus,
        input[type="number"]:focus,
        input[type="color"]:focus,
        select:focus,
        textarea:focus {
            outline: 2px solid #667eea;
            outline-offset: 1px;
            border-color: #667eea;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 0 0 3px rgba(102, 126, 234, 0.15);
        }
        
        input[type="range"]:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
        
        input[type="range"]:focus::-webkit-slider-thumb {
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3), var(--shadow-md);
            transform: scale(1.1);
        }
        
        input[type="range"]:focus::-moz-range-thumb {
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3), var(--shadow-md);
            transform: scale(1.1);
        }
        
        input[type="radio"]:focus + label,
        input[type="checkbox"]:focus + label {
            outline: 2px solid #667eea;
            outline-offset: 2px;
            background: rgba(102, 126, 234, 0.08);
        }
        
        .switch:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15);
        }
        
        .mobile-fab:focus,
        #theme-toggle:focus {
            outline: 2px solid #667eea;
            outline-offset: 3px;
    box-shadow: var(--shadow-inset), 0 0 0 4px rgba(102, 126, 234, 0.2), var(--shadow-xl);
        }
        
        .lightbox-nav:focus,
        .lightbox-close:focus,
        .lightbox-download:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2), var(--shadow-lg);
        }
        
        .copy-button:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15), var(--shadow-md);
        }
        
        .slice-item:focus {
            outline: 2px solid #667eea;
            outline-offset: 3px;
            transform: translateY(-2px);
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15), var(--shadow-xl);
        }
        
        .collapsible-header:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
            background: var(--glass-secondary);
        }
        
        [data-theme="light"] .action-button:focus,
        [data-theme="light"] .secondary-button:focus,
        [data-theme="light"] button:focus {
            outline-color: #3b82f6;
    box-shadow: var(--shadow-inset), 0 0 0 3px rgba(59, 130, 246, 0.15), var(--shadow-lg);
        }
        
        [data-theme="light"] input[type="text"]:focus,
        [data-theme="light"] input[type="number"]:focus,
        [data-theme="light"] input[type="color"]:focus,
        [data-theme="light"] select:focus {
            outline-color: #3b82f6;
            border-color: #3b82f6;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        
        [data-theme="light"] input[type="range"]:focus {
            outline-color: #3b82f6;
        }
        
        [data-theme="light"] input[type="radio"]:focus + label,
        [data-theme="light"] input[type="checkbox"]:focus + label {
            outline-color: #3b82f6;
            background: rgba(59, 130, 246, 0.08);
        }

        #theme-toggle:active {
            transform: scale(0.9);
    box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.2), var(--shadow-md);
}

        .copy-button:active {
            transform: scale(0.9);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), var(--shadow-sm);
        }
        
        .slice-item:active {
            transform: translateY(-1px) scale(0.98);
        }
        
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.2);
    box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.4), var(--shadow-lg);
        }
        
        input[type="range"]:active::-moz-range-thumb {
            transform: scale(1.2);
    box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.4), var(--shadow-lg);
        }
        
        input[type="radio"]:active + label,
        input[type="checkbox"]:active + label {
            transform: scale(0.98);
            background: rgba(102, 126, 234, 0.12);
        }
        
        .collapsible-header:active {
            transform: scale(0.99);
            background: var(--glass-highlight);
        }

.success-pulse {
    animation: successPulse 0.6s ease-out, successGlow 1s ease-out;
}

        @keyframes successPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes successGlow {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }

        .field-error {
            display: block;
    color: var(--color-error);
            font-size: 0.875rem;
            margin-top: 0.375rem;
            padding: 0.25rem 0.5rem;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: var(--radius-md);
            backdrop-filter: blur(var(--blur-light));
            animation: errorSlideIn 0.3s ease-out;
        }
        
        @keyframes errorSlideIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

        .input-error {
    border: 2px solid var(--color-error) !important;
            background: rgba(239, 68, 68, 0.05) !important;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 0 0 3px rgba(239, 68, 68, 0.15) !important;
        }
        
        .input-error:focus {
    outline-color: var(--color-error) !important;
    border-color: var(--color-error) !important;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 0 0 3px rgba(239, 68, 68, 0.25) !important;
}

        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .shake-error {
            animation: errorShake 0.5s ease-in-out;
        }
        
        .input-success {
    border: 2px solid var(--color-success) !important;
            background: rgba(34, 197, 94, 0.05) !important;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 0 0 3px rgba(34, 197, 94, 0.15) !important;
        }
        
        .field-container {
            position: relative;
        }
        
        .error-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
    color: var(--color-error);
            pointer-events: none;
            z-index: 10;
        }
        
        [data-theme="light"] .field-error {
    background: rgba(220, 38, 38, 0.08);
    border-color: rgba(220, 38, 38, 0.3);
            color: #dc2626;
        }
        
        [data-theme="light"] .input-error {
            border-color: #dc2626 !important;
            background: rgba(220, 38, 38, 0.05) !important;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 0 0 3px rgba(220, 38, 38, 0.15) !important;
        }

        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
    background: var(--glass-secondary);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transform: translateY(-4px);
    transition: all var(--transition-fast);
            color: rgba(255, 255, 255, 0.8);
            z-index: 10;
            min-width: 44px;
            min-height: 44px;
        }

        .slice-item:hover .copy-button {
            opacity: 1;
            transform: translateY(0);
        }

        .copy-button:hover {
            background: var(--glass-secondary);
            border-color: var(--glass-border-strong);
    color: #fff;
            transform: scale(1.1);
        }

        .copy-button:active {
            transform: scale(0.95);
        }

        .copy-button svg {
            width: 16px;
            height: 16px;
        }

        .copy-button.copying {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.4);
    color: #22c55e;
        }

        .copy-button.copied {
            background: rgba(34, 197, 94, 0.3);
            border-color: rgba(34, 197, 94, 0.5);
    color: #22c55e;
}

.animate-spin {
    animation: spin 1s linear infinite;
}

/* Gradient title helper */
.gradient-title {
    background: linear-gradient(135deg, #93c5fd, #c4b5fd 40%, #f0abfc 100%);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
}

/* ===== Solid surfaces variant (remove glass effects) ===== */
/* Remap glass tokens to opaque surfaces */
:root {
    --panel-surface: #101825;
    --panel-surface-2: #0d1729;
    --panel-border: rgba(148, 163, 184, 0.12);
    --panel-border-strong: rgba(148, 163, 184, 0.18);
    --glass-bg: var(--panel-surface);
    --glass-secondary: var(--panel-surface-2);
    --glass-fallback: var(--panel-surface);
    --glass-border: var(--panel-border);
    --glass-border-strong: var(--panel-border-strong);
}

[data-theme="light"] {
    --panel-surface: #ffffff;
    --panel-surface-2: #f8fafc;
    --panel-border: rgba(100, 116, 139, 0.18);
    --panel-border-strong: rgba(100, 116, 139, 0.26);
    --glass-bg: var(--panel-surface);
    --glass-secondary: var(--panel-surface-2);
    --glass-fallback: var(--panel-surface);
    --glass-border: var(--panel-border);
    --glass-border-strong: var(--panel-border-strong);
}

/* Kill all backdrop blur usage */
.glass-card,
.card-header,
.secondary-button,
.info-box,
.bottom-sheet,
.swipe-indicator,
.lightbox-nav,
.lightbox-close,
.lightbox-info,
#video-settings select,
#video-settings input[type="number"],
.progress-container,
.copy-button,
.lightbox {
    -webkit-backdrop-filter: none !important;
    backdrop-filter: none !important;
}

/* Remove sheen and decorative ring */
.glass-sheen { display: none !important; }
.glass-card::after { content: none !important; }

/* Ensure core surfaces are solid */
.glass-card { background: var(--glass-bg) !important; }
.card-header { background: var(--glass-secondary) !important; }
.info-box { background: var(--glass-secondary) !important; }
.bottom-sheet { background: var(--glass-bg) !important; }
.lightbox-nav,
.lightbox-close,
.lightbox-info,
.copy-button,
.swipe-indicator,
.progress-container {
    background: var(--glass-secondary) !important;
}

/* Light mode: override dark Tailwind utility colors inside panels */
[data-theme="light"] .bg-slate-800\/50,
[data-theme="light"] .bg-slate-700\/50,
[data-theme="light"] .bg-slate-900\/50,
[data-theme="light"] .bg-slate-900,
[data-theme="light"] .bg-slate-800 {
    background-color: var(--panel-surface-2) !important;
}
[data-theme="light"] .border-slate-700,
[data-theme="light"] .border-slate-600 {
    border-color: var(--panel-border) !important;
}
[data-theme="light"] .text-slate-200,
[data-theme="light"] .text-slate-300 {
    color: var(--text-secondary) !important;
}
[data-theme="light"] .text-slate-400 { color: #64748b !important; }
[data-theme="light"] .placeholder-slate-400::placeholder { color: #94a3b8 !important; }

@media (max-width: 768px) {
    .glass-card {
        border-radius: 1rem;
        margin: 0.5rem;
    }
    
    .card-header {
        padding: 1rem;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
    }
    
    .action-button, .secondary-button {
        min-height: 48px;
        padding: 0.875rem 1.5rem;
        font-size: 1rem;
    }
    
    .mobile-grid {
        grid-template-columns: 1fr !important;
        gap: 1rem !important;
    }
    
    .mobile-grid > div:nth-child(5) {
        grid-column: 1 / -1;
    }
    
    input[type="number"], input[type="range"], select {
        min-height: 44px;
        font-size: 16px;
    }
    
    .custom-range::-webkit-slider-thumb {
        width: 24px;
        height: 24px;
    }
    
    .custom-range::-moz-range-thumb {
        width: 24px;
        height: 24px;
    }
    
    #panning-video {
        max-height: 50vh;
        object-fit: contain;
    }
    
    .mobile-fab {
        display: flex;
    }
    
    .mobile-hide {
        display: none !important;
    }
    
    .mobile-show-in-sheet {
        display: block !important;
    }
    
    .lightbox-nav {
        width: 44px;
        height: 44px;
    }
    
    .lightbox-nav.prev {
        left: 1rem;
    }
    
    .lightbox-nav.next {
        right: 1rem;
    }
    
    .lightbox-close {
        top: 1rem;
        right: 1rem;
        width: 44px;
        height: 44px;
    }
    
    .lightbox-info {
        bottom: 1rem;
        left: 1rem;
        right: 1rem;
        transform: none;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
    }
}

@supports (-webkit-touch-callout: none) {
    body {
        -webkit-touch-callout: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
    
    input, button, select {
        appearance: none;
        border-radius: 0.5rem;
    }
    
    input[type="color"] {
        width: 44px;
        height: 44px;
    }
}

@supports (padding: max(0px)) {
    body {
        padding-left: max(1rem, env(safe-area-inset-left));
        padding-right: max(1rem, env(safe-area-inset-right));
        padding-bottom: max(1rem, env(safe-area-inset-bottom));
    }
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 font-sans antialiased">
    <div id="app" class="relative min-h-screen p-4 sm:p-6 lg:p-8 flex flex-col items-center">

        <!-- Theme Toggle -->
        <button id="shortcuts-btn" class="fixed top-4 right-20 z-50 w-12 h-12 rounded-full bg-white/10 backdrop-blur-md border border-white/20 flex items-center justify-center transition-all duration-300 hover:bg-white/20 hover:scale-110" aria-label="Keyboard shortcuts">
            <i data-lucide="keyboard" class="w-5 h-5 text-white"></i>
        </button>
        <button id="theme-toggle" class="fixed top-4 right-4 z-50 w-12 h-12 rounded-full bg-white/10 backdrop-blur-md border border-white/20 flex items-center justify-center transition-all duration-300 hover:bg-white/20 hover:scale-110" aria-label="Toggle theme">
            <svg id="theme-icon-dark" class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
            </svg>
            <svg id="theme-icon-light" class="w-5 h-5 text-gray-800 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
            </svg>
        </button>

        <!-- Interactive Aurora Background -->
        <div id="aurora-background" class="absolute inset-0 overflow-hidden pointer-events-none z-0">
            <div id="aurora-orb-1" class="absolute w-96 h-96 rounded-full blur-3xl transition-all duration-1000 ease-out" 
                 style="background: radial-gradient(circle, rgba(102, 126, 234, 0.25) 0%, rgba(102, 126, 234, 0.1) 40%, transparent 70%); 
                        left: var(--orb-1-x, 25%); top: var(--orb-1-y, 25%); transform: translate(-50%, -50%);"></div>
            <div id="aurora-orb-2" class="absolute w-80 h-80 rounded-full blur-3xl transition-all duration-1200 ease-out" 
                 style="background: radial-gradient(circle, rgba(168, 85, 247, 0.2) 0%, rgba(168, 85, 247, 0.08) 40%, transparent 70%); 
                        left: var(--orb-2-x, 75%); top: var(--orb-2-y, 75%); transform: translate(-50%, -50%);"></div>
            <div id="aurora-orb-3" class="absolute w-64 h-64 rounded-full blur-2xl transition-all duration-800 ease-out" 
                 style="background: radial-gradient(circle, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.06) 40%, transparent 70%); 
                        left: var(--orb-3-x, 50%); top: var(--orb-3-y, 50%); transform: translate(-50%, -50%);"></div>
                 </div>



        <main id="main-content" class="w-full max-w-4xl z-10">
            <!-- Error Message -->
            <div id="error-message" class="hidden glass-card border-red-500/50 mb-6 p-4" role="alert" aria-live="assertive">
                <div class="flex items-start justify-between gap-4">
                    <div class="flex items-start gap-3">
                        <i data-lucide="alert-circle" class="w-6 h-6 text-red-400 flex-shrink-0"></i>
                        <div class="space-y-1">
                            <p class="text-red-300 font-semibold">Something went wrong</p>
                            <ul id="error-suggestions" class="list-disc list-inside text-slate-300 text-sm space-y-1">
                                <!-- Suggestions inserted dynamically based on error type -->
                            </ul>
                    </div>
                    </div>
                    <button id="dismiss-error" class="p-2 rounded-full hover:bg-slate-700/50 transition-colors touch-target" aria-label="Dismiss error">
                        <i data-lucide="x" class="w-5 h-5 text-slate-400"></i>
                    </button>
                </div>
            </div>

            <!-- Upload Area -->
            <div id="upload-area" class="glass-card text-center p-8 sm:p-12">
                <div class="glass-sheen"></div>
                <div class="border-2 border-dashed border-slate-600/40 rounded-3xl p-8 transition-all duration-300 backdrop-blur-sm">
                    <div class="flex flex-col items-center justify-center space-y-4">
                        <div class="w-16 h-16 rounded-3xl flex items-center justify-center bg-slate-700/50 border border-slate-600">
                           <i data-lucide="upload-cloud" class="w-8 h-8 text-indigo-400"></i>
                        </div>
                        <p class="text-lg font-semibold text-slate-200">Drag & drop your panorama here</p>
                        <p class="text-slate-400">or</p>
                        <label for="file-input" class="file-input-label action-button cursor-pointer">
                            <i data-lucide="file-image" class="w-4 h-4 mr-2"></i>
                            Select File
                        </label>
                        <input type="file" id="file-input" class="hidden" accept="image/png, image/jpeg, image/webp, image/avif">
                        <p class="text-xs text-slate-500 mt-4">Supports JPG, PNG, WebP, & AVIF</p>
                        
                        <!-- Upload Preview -->
                        <div id="upload-preview" class="upload-preview">
                            <img id="upload-preview-img" alt="Upload preview" />
                        </div>
                    </div>
                </div>
            </div>

            <!-- Preview & Controls -->
            <div id="preview-container" class="hidden">
                <div class="glass-card mb-6">
                    <div class="glass-sheen"></div>
                    <h2 class="card-header">
                        <i data-lucide="image" class="w-5 h-5 mr-2"></i>
                        <span class="gradient-title">Image Preview</span>
                    </h2>
                    <div class="p-6">
                        <div class="flex items-center justify-between mb-4 gap-3">
                            <div class="flex items-center gap-2 text-slate-400 text-sm min-w-0">
                                <i data-lucide="file" class="w-4 h-4"></i>
                                <span id="selected-filename-preview" class="truncate max-w-[60vw]"></span>
                            </div>
                            <button id="change-file-btn" class="secondary-button touch-target inline-flex items-center gap-2" type="button">
                                <i data-lucide="file-up" class="w-4 h-4"></i>
                                Change File
                            </button>
                        </div>
                        <div class="relative group overflow-hidden rounded-xl">
                            <img id="preview-img" class="rounded-xl max-w-full h-auto mx-auto shadow-lg select-none" alt="Image Preview">
                            <div id="preview-zoom-hint" class="absolute bottom-2 right-2 text-xs bg-slate-800/70 border border-slate-600 text-slate-200 px-2 py-1 rounded-md opacity-0 group-hover:opacity-100 transition-opacity">Pinch/scroll to zoom</div>
                            <!-- Visual watermark position grid overlay (toggle visibility when watermark enabled) -->
                            <div id="watermark-grid" class="pointer-events-none absolute inset-0 grid grid-cols-3 grid-rows-3 opacity-0 transition-opacity">
                                <div class="border border-white/10"></div>
                                <div class="border border-white/10"></div>
                                <div class="border border-white/10"></div>
                                <div class="border border-white/10"></div>
                                <div class="border border-white/10"></div>
                                <div class="border border-white/10"></div>
                                <div class="border border-white/10"></div>
                                <div class="border border-white/10"></div>
                                <div class="border border-white/10"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Full View BG Settings -->
                <div id="full-view-settings" class="glass-card mb-6 collapsible-section mobile-hide">
                    <div class="glass-sheen"></div>
                    <div class="collapsible-header" id="full-view-toggle">
                        <div class="flex items-center">
                        <i data-lucide="image-play" class="w-5 h-5 mr-2"></i>
                        <span class="gradient-title">Full View Background</span>
                        </div>
                        <i data-lucide="chevron-down" class="w-5 h-5 expand-icon"></i>
                    </div>
                    <div class="collapsible-content" id="full-view-content">
                    <div class="p-6 space-y-6">
                        <div class="flex items-center justify-between p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                            <label for="bg-type-blur" class="font-semibold text-slate-200">Background Type</label>
                            <div class="radio-group flex items-center gap-4">
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="bg-type" id="bg-type-blur" value="blur" checked>
                                    Blur
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="bg-type" id="bg-type-color" value="color">
                                    Color
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="bg-type" id="bg-type-gradient" value="gradient">
                                    Gradient
                                </label>
                            </div>
                        </div>

                        <!-- Blur Controls (Fast Separable/StackBlur) -->
                        <div id="blur-controls" class="space-y-4">
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div>
                                    <label for="blur-intensity" class="font-semibold text-slate-200">Blur Radius</label>
                                    <input type="range" id="blur-intensity" min="0" max="40" value="10" class="custom-range">
                                </div>
                                <div>
                                    <label for="blur-downscale" class="font-semibold text-slate-200">Downscale % (perf)</label>
                                    <input type="range" id="blur-downscale" min="10" max="100" value="35" class="custom-range">
                                    <p class="text-xs text-slate-400 mt-1">Lower = faster. We blur a smaller copy and upscale.</p>
                                </div>
                            </div>
                        </div>

                        <!-- Color Controls -->
                        <div id="color-controls" class="hidden space-y-4">
                            <label class="font-semibold text-slate-200">Background Color</label>
                            <div class="flex items-center gap-4">
                                <input type="color" id="bg-color-picker" value="#FFFFFF">
                                <div id="color-palette" class="flex items-center gap-2">
                                    <!-- Color swatches will be inserted here -->
                                </div>
                            </div>
                        </div>

                        <!-- Gradient Controls -->
                        <div id="gradient-controls" class="hidden space-y-4">
                            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                                <div>
                                    <label for="gradient-type" class="font-semibold text-slate-200">Gradient Type</label>
                                    <select id="gradient-type" class="w-full p-2 rounded-lg bg-slate-700/50 border border-slate-600 text-slate-200 focus:border-blue-500 focus:outline-none">
                                        <option value="radial">Radial</option>
                                        <option value="angular">Angular</option>
                                        <option value="linear">Linear</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="gradient-stops" class="font-semibold text-slate-200">Colors</label>
                                    <input type="number" id="gradient-stops" min="3" max="5" value="4" class="w-full p-2 rounded-lg bg-slate-700/50 border border-slate-600 text-slate-200 focus:border-blue-500 focus:outline-none">
                                </div>
                                <div>
                                    <label for="gradient-blend" class="font-semibold text-slate-200">Blend</label>
                                    <select id="gradient-blend" class="w-full p-2 rounded-lg bg-slate-700/50 border border-slate-600 text-slate-200 focus:border-blue-500 focus:outline-none">
                                        <option value="soft-light">Soft Light</option>
                                        <option value="overlay">Overlay</option>
                                        <option value="normal" selected>Normal</option>
                                    </select>
                                </div>
                            </div>
                            <div class="flex items-center gap-4">
                                <button id="palette-from-image" class="secondary-button">
                                    <span class="btn-text flex items-center">
                                        <i data-lucide="palette" class="w-4 h-4 mr-2"></i>
                                        Use Image Palette
                                    </span>
                                </button>
                                <div id="gradient-preview" class="flex-1 h-10 rounded-lg border border-slate-700"></div>
                    </div>
                </div>

                        <!-- Watermark Controls -->
                        <div class="space-y-4">
                            <label class="font-semibold text-slate-200">Watermark</label>
                            
                            <!-- Watermark Type Selection -->
                            <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                <label class="block text-sm text-slate-300 mb-3">Watermark Type</label>
                                <div class="radio-group flex items-center gap-4">
                                    <label class="flex items-center gap-2">
                                        <input type="radio" name="watermark-type" value="none" checked class="sr-only">
                                        <span class="text-sm">None</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input type="radio" name="watermark-type" value="image" class="sr-only">
                                        <span class="text-sm">Image</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input type="radio" name="watermark-type" value="text" class="sr-only">
                                        <span class="text-sm">Text</span>
                                    </label>
                    </div>
                </div>

                            <!-- Text Watermark Controls -->
                            <div id="text-watermark-controls" class="hidden space-y-4">
                                <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                    <label for="watermark-text" class="block text-sm text-slate-300 mb-2">Watermark Text</label>
                                    <input type="text" id="watermark-text" placeholder="Enter your watermark text..." 
                                           class="w-full p-2 rounded-lg bg-slate-700/50 border border-slate-600 text-slate-200 placeholder-slate-400 focus:border-blue-500 focus:outline-none">
                                </div>
                                
                                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                    <!-- Font Size -->
                                    <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                        <label for="watermark-font-size" class="block text-sm text-slate-300 mb-2">Font Size</label>
                                        <div class="flex items-center gap-3">
                                            <input type="range" id="watermark-font-size" min="12" max="72" value="24" class="custom-range flex-1">
                                            <span id="watermark-font-size-label" class="text-slate-400 w-12 text-right text-sm">24px</span>
                                        </div>
                                    </div>
                                    
                                    <!-- Text Color -->
                                    <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                        <label for="watermark-text-color" class="block text-sm text-slate-300 mb-2">Text Color</label>
                                        <input type="color" id="watermark-text-color" value="#FFFFFF" 
                                               class="w-full h-10 rounded-lg border border-slate-600 bg-slate-700/50">
                                    </div>
                                </div>
                                
                                <!-- Font Weight & Style -->
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                        <label for="watermark-font-weight" class="block text-sm text-slate-300 mb-2">Font Weight</label>
                                        <select id="watermark-font-weight" class="w-full p-2 rounded-lg bg-slate-700/50 border border-slate-600 text-slate-200">
                                            <option value="normal">Normal</option>
                                            <option value="bold" selected>Bold</option>
                                            <option value="bolder">Extra Bold</option>
                                        </select>
                                    </div>
                                    
                                    <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                        <label for="watermark-text-stroke" class="block text-sm text-slate-300 mb-2">Text Outline</label>
                                        <select id="watermark-text-stroke" class="w-full p-2 rounded-lg bg-slate-700/50 border border-slate-600 text-slate-200">
                                            <option value="none">None</option>
                                            <option value="thin" selected>Thin</option>
                                            <option value="thick">Thick</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- Text Watermark Positioning & Size Controls -->
                                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                    <!-- Opacity -->
                                    <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                        <label for="text-watermark-opacity" class="block text-sm text-slate-300 mb-2">Opacity</label>
                                        <div class="flex items-center gap-3">
                                            <input type="range" id="text-watermark-opacity" min="10" max="100" value="70" class="custom-range flex-1">
                                            <span id="text-watermark-opacity-label" class="text-slate-400 w-12 text-right text-sm">70%</span>
                                        </div>
                                    </div>

                                    <!-- Size -->
                                    <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                        <label for="text-watermark-size" class="block text-sm text-slate-300 mb-2">Size</label>
                                        <div class="flex items-center gap-3">
                                            <input type="range" id="text-watermark-size" min="5" max="50" value="15" class="custom-range flex-1">
                                            <span id="text-watermark-size-label" class="text-slate-400 w-12 text-right text-sm">15%</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Position -->
                                <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                    <label class="block text-sm text-slate-300 mb-3">Position</label>
                                    <div class="radio-group grid grid-cols-3 gap-2">
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="text-watermark-position" value="top-left" class="sr-only">
                                            <i data-lucide="corner-up-left" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="text-watermark-position" value="top-center" class="sr-only">
                                            <i data-lucide="arrow-up" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="text-watermark-position" value="top-right" class="sr-only">
                                            <i data-lucide="corner-up-right" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="text-watermark-position" value="center-left" class="sr-only">
                                            <i data-lucide="arrow-left" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="text-watermark-position" value="center" class="sr-only">
                                            <i data-lucide="plus" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="text-watermark-position" value="center-right" class="sr-only">
                                            <i data-lucide="arrow-right" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="text-watermark-position" value="bottom-left" class="sr-only">
                                            <i data-lucide="corner-down-left" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="text-watermark-position" value="bottom-center" class="sr-only">
                                            <i data-lucide="arrow-down" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer checked">
                                            <input type="radio" name="text-watermark-position" value="bottom-right" checked class="sr-only">
                                            <i data-lucide="corner-down-right" class="w-4 h-4"></i>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Image Watermark Upload -->
                            <div id="image-watermark-controls" class="hidden">
                            <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                <label for="watermark-input" class="block text-sm text-slate-300 mb-2">Upload PNG Watermark</label>
                                <div class="flex items-center gap-3">
                                    <input type="file" id="watermark-input" accept="image/png" class="hidden">
                                    <button id="watermark-upload-btn" class="secondary-button text-sm px-3 py-2">
                                        <i data-lucide="upload" class="w-4 h-4 mr-2"></i>
                                        Choose PNG
                                    </button>
                                    <span id="watermark-filename" class="text-sm text-slate-400">No file selected</span>
                                    <button id="watermark-remove-btn" class="hidden text-red-400 hover:text-red-300 transition-colors">
                                        <i data-lucide="x" class="w-4 h-4"></i>
                                    </button>
                                </div>
                                                                <div id="watermark-preview" class="hidden mt-3 p-2 rounded-lg bg-slate-700/50 border border-slate-600">
                                    <img id="watermark-preview-img" class="max-w-20 max-h-20 object-contain" alt="Watermark preview">
                                </div>
                            </div>
                            </div>

                            <!-- Watermark Settings (for both image and text) -->
                            <div id="watermark-settings" class="hidden space-y-4">
                                <!-- Opacity -->
                                <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                    <label for="watermark-opacity" class="block text-sm text-slate-300 mb-2">Opacity</label>
                                    <div class="flex items-center gap-3">
                                        <input type="range" id="watermark-opacity" min="10" max="100" value="70" class="custom-range flex-1">
                                        <span id="watermark-opacity-label" class="text-slate-400 w-12 text-right text-sm">70%</span>
                                    </div>
                                </div>

                                <!-- Size -->
                                <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                    <label for="watermark-size" class="block text-sm text-slate-300 mb-2">Size</label>
                                    <div class="flex items-center gap-3">
                                        <input type="range" id="watermark-size" min="5" max="50" value="15" class="custom-range flex-1">
                                        <span id="watermark-size-label" class="text-slate-400 w-12 text-right text-sm">15%</span>
                                    </div>
                                </div>

                                <!-- Position -->
                                <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                    <label class="block text-sm text-slate-300 mb-3">Position</label>
                                    <div class="radio-group grid grid-cols-3 gap-2">
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="watermark-position" value="top-left" class="sr-only">
                                            <i data-lucide="corner-up-left" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="watermark-position" value="top-center" class="sr-only">
                                            <i data-lucide="arrow-up" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="watermark-position" value="top-right" class="sr-only">
                                            <i data-lucide="corner-up-right" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="watermark-position" value="center-left" class="sr-only">
                                            <i data-lucide="arrow-left" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="watermark-position" value="center" class="sr-only">
                                            <i data-lucide="plus" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="watermark-position" value="center-right" class="sr-only">
                                            <i data-lucide="arrow-right" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="watermark-position" value="bottom-left" class="sr-only">
                                            <i data-lucide="corner-down-left" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer">
                                            <input type="radio" name="watermark-position" value="bottom-center" class="sr-only">
                                            <i data-lucide="arrow-down" class="w-4 h-4"></i>
                                        </label>
                                        <label class="flex items-center justify-center p-2 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors cursor-pointer checked">
                                            <input type="radio" name="watermark-position" value="bottom-right" checked class="sr-only">
                                            <i data-lucide="corner-down-right" class="w-4 h-4"></i>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>

                <div id="controls" class="glass-card mobile-hide">
                    <div class="glass-sheen"></div>
                    <h2 class="card-header">
                        <i data-lucide="sliders-horizontal" class="w-5 h-5 mr-2"></i>
                        <span class="gradient-title">Slicing Settings</span>
                    </h2>
                    <div class="p-6 space-y-6">
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm">
                            <div class="info-box">
                                <span class="text-slate-400">Original Size</span>
                                <strong id="original-size" class="font-mono">...</strong>
                            </div>
                            <div class="info-box">
                                <span class="text-slate-400">Scaled Size</span>
                                <strong id="scaled-size" class="font-mono">...</strong>
                            </div>
                             <div class="info-box">
                                <span class="text-slate-400">Slice Count</span>
                                <strong id="slice-count" class="font-mono">...</strong>
                            </div>
                            <div class="info-box">
                                <span class="text-slate-400">Slice Resolution</span>
                                <strong id="slice-resolution" class="font-mono">...</strong>
                            </div>
                        </div>

                        <div class="flex items-center justify-between p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                              <div>
                                  <label for="high-res-toggle" class="font-semibold text-slate-200">High-Resolution Mode</label>
                                  <p class="text-xs text-slate-400 mt-1">Use original image height for maximum quality</p>
                              </div>
                            <label class="switch">
                                <input type="checkbox" id="high-res-toggle" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        
                        <div class="flex flex-col sm:flex-row gap-4 pt-4 border-t border-slate-700/50">
                            <button id="reset-btn" class="secondary-button w-full sm:w-auto">
                                <i data-lucide="rotate-ccw" class="w-4 h-4 mr-2"></i>
                                Reset
                            </button>
                            <button id="process-btn" class="action-button flex-1">
                                <span class="btn-text flex items-center justify-center">
                                    <i data-lucide="sparkles" class="w-4 h-4 mr-2"></i>
                                    Generate Slices
                                </span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Panning Video Settings -->
                <div id="video-settings" class="glass-card mt-6 collapsible-section mobile-hide">
                    <div class="glass-sheen"></div>
                    <div class="collapsible-header" id="video-toggle">
                        <div class="flex items-center">
                            <i data-lucide="video" class="w-5 h-5 mr-2"></i>
                            <span class="gradient-title">Panning Video</span>
                        </div>
                        <i data-lucide="chevron-down" class="w-5 h-5 expand-icon"></i>
                    </div>
                    <div class="collapsible-content" id="video-content">
                        <div class="p-6 space-y-6">
                        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 mobile-grid">
                            <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                <label for="video-format" class="font-semibold text-slate-200 flex items-center gap-2"><i data-lucide="file-video" class="w-4 h-4"></i>Format</label>
                                <select id="video-format" aria-label="Video format" class="mt-2 w-full bg-slate-900/50 border border-slate-700 rounded-lg px-3 py-2 text-slate-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                    <option value="webm" selected>WebM (fastest)</option>
                                    <option value="mp4">MP4 H.264 (in-browser)</option>
                                </select>
                                <p class="text-xs text-slate-400 mt-2">MP4 tries native recording when available; otherwise transcodes in-browser</p>
                            </div>
                            <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                <label for="video-easing" class="font-semibold text-slate-200 flex items-center gap-2"><i data-lucide="activity" class="w-4 h-4"></i>Easing</label>
                                <select id="video-easing" aria-describedby="easing-description" class="mt-2 w-full bg-slate-900/50 border border-slate-700 rounded-lg px-3 py-2 text-slate-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                    <option value="linear" selected>Linear</option>
                                    <option value="ease">Ease</option>
                                    <option value="ease-in">Ease In</option>
                                    <option value="ease-out">Ease Out</option>
                                    <option value="ease-in-out">Ease In-Out</option>
                                    <option value="smooth">Smooth</option>
                                    <option value="bounce">Bounce</option>
                                </select>
                                <p id="easing-description" class="text-xs text-slate-400 mt-2">Constant speed throughout</p>
                            </div>
                            <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                <label for="video-duration" class="font-semibold text-slate-200 flex items-center gap-2"><i data-lucide="timer" class="w-4 h-4"></i>Duration (seconds)</label>
                                <input id="video-duration" type="number" min="2" max="120" step="1" value="10" inputmode="numeric" class="mt-2 w-full bg-slate-900/50 border border-slate-700 rounded-lg px-3 py-2 text-slate-200 focus:outline-none focus:ring-2 focus:ring-indigo-500" />
                                <p class="text-xs text-slate-400 mt-2">Left → right → left across the whole image</p>
                            </div>
                            <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700">
                                <label for="video-fps" class="font-semibold text-slate-200 flex items-center gap-2"><i data-lucide="zap" class="w-4 h-4"></i>Frames per second</label>
                                <input id="video-fps" type="number" min="10" max="60" step="1" value="30" inputmode="numeric" class="mt-2 w-full bg-slate-900/50 border border-slate-700 rounded-lg px-3 py-2 text-slate-200 focus:outline-none focus:ring-2 focus:ring-indigo-500" />
                                <p class="text-xs text-slate-400 mt-2">Higher FPS = smoother, larger file</p>
                            </div>
                            <div class="p-4 rounded-2xl bg-slate-800/50 border border-slate-700 lg:col-span-2 xl:col-span-1">
                                <label for="video-quality" class="font-semibold text-slate-200 flex items-center gap-2"><i data-lucide="sliders" class="w-4 h-4"></i>Quality</label>
                                <div class="mt-2 flex items-center gap-3">
                                    <input id="video-quality" type="range" min="10" max="100" step="5" value="80" class="custom-range flex-1 min-w-0" />
                                    <span id="video-quality-label" class="text-slate-400 w-20 text-right text-sm whitespace-nowrap">≈ 8 Mbps</span>
                                </div>
                                <p class="text-xs text-slate-400 mt-2">Controls bitrate. Higher = cleaner, larger file</p>
                            </div>
                        </div>

                        <div class="flex flex-col sm:flex-row gap-4 pt-2">
                            <button id="generate-video-btn" class="action-button flex-1">
                                <span class="btn-text flex items-center justify-center">
                                    <i data-lucide="play-circle" class="w-4 h-4 mr-2"></i>
                                    Generate Panning Video
                                </span>
                                <span class="btn-loader hidden"></span>
                            </button>
                        </div>

                        <p class="text-xs text-slate-500">Exports without background blur/color. WebM is fastest. MP4 is done in-browser via native recording when possible or in-browser transcoding.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Result Area -->
            <div id="result-container" class="hidden mt-8">
                <div class="glass-card">
                    <div class="glass-sheen"></div>
                    <div class="card-header flex-col sm:flex-row">
                        <div class="flex items-center mb-4 sm:mb-0">
                            <i data-lucide="check-circle" class="w-5 h-5 mr-2 text-emerald-400"></i>
                            <span class="gradient-title">Processing Complete!</span>
                        </div>
                        <div class="flex flex-col sm:flex-row gap-3">
                            <button id="download-btn" class="action-button">
                            <span class="btn-text flex items-center">
                                <i data-lucide="download" class="w-4 h-4 mr-2"></i>
                                Download All (.zip)
                            </span>
                            <span class="btn-loader hidden"></span>
                        </button>
                            <button id="process-another-btn" class="secondary-button">
                                <span class="btn-text flex items-center">
                                    <i data-lucide="image-plus" class="w-4 h-4 mr-2"></i>
                                    Process Another Image
                                </span>
                        </button>
                        </div>
                    </div>
                    <div id="slices-preview" class="p-6 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                        <!-- Slices will be dynamically inserted here -->
                    </div>
                    <div class="px-6 pb-6 text-xs text-slate-500">
                        Tip: Click any image to view it larger. Use the copy button in the top-right of each tile to copy directly to your clipboard.
                    </div>
                </div>
                
                <!-- Video Result -->
                <div id="video-result-card" class="hidden glass-card mt-6">
                    <div class="glass-sheen"></div>
                    <div class="card-header flex-col sm:flex-row">
                        <div class="flex items-center">
                            <i data-lucide="film" class="w-5 h-5 mr-2 text-indigo-400"></i>
                            <span class="gradient-title">Panning Video Ready</span>
                        </div>
                        <button id="download-video-btn" class="action-button mt-4 sm:mt-0">
                            <span class="btn-text flex items-center">
                                <i data-lucide="download" class="w-4 h-4 mr-2"></i>
                                Download Video
                            </span>
                            <span class="btn-loader hidden"></span>
                        </button>
                    </div>
                    <div class="p-6">
                        <video id="panning-video" class="rounded-xl w-full h-auto shadow-lg" controls playsinline></video>
                        <p class="text-xs text-slate-500 mt-3">Format: <span id="video-format-label">WebM</span></p>
                    </div>
                </div>
            </div>
        </main>
        
        <footer class="w-full max-w-4xl text-center mt-12 text-slate-500 text-sm z-10">
            <p>This project was originally a fork of FUTC's work, but the codebase has since been completely overhauled.<br>All processing happens locally in your browser.</p>
        </footer>
    </div>

    <!-- Enhanced Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-slate-900/80 backdrop-blur-sm flex flex-col items-center justify-center z-50 transition-opacity duration-300 opacity-0 pointer-events-none">
        <div class="glass-card p-8 max-w-md w-full mx-4">
            <div class="glass-sheen"></div>
            <div class="text-center space-y-4">
                <div class="loader mx-auto"></div>
                <p id="loading-text" class="text-lg text-slate-300 font-medium">Processing...</p>
                <div id="progress-container" class="progress-container hidden">
                    <div id="progress-bar" class="progress-bar" style="width: 0%"></div>
                </div>
                <p id="progress-text" class="text-sm text-slate-400 hidden">Step 1 of 4</p>
            </div>
        </div>
    </div>

    <!-- Success Animation -->
    <div id="success-overlay" class="fixed inset-0 bg-slate-900/60 backdrop-blur-sm flex flex-col items-center justify-center z-50 transition-opacity duration-300 opacity-0 pointer-events-none">
        <div class="success-checkmark">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                <path class="checkmark-path" d="M20 6L9 17l-5-5"/>
            </svg>
        </div>
        <p class="mt-4 text-lg text-white font-medium">Complete!</p>
    </div>

    <!-- Mobile FAB -->
    <button id="mobile-fab" class="mobile-fab" aria-label="Open Settings">
        <svg data-lucide="settings" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    </button>

    <!-- Enhanced Bottom Sheet for Mobile Settings -->
    <div id="bottom-sheet-backdrop" class="bottom-sheet-backdrop"></div>
    <div id="bottom-sheet" class="bottom-sheet">
        <div class="bottom-sheet-handle" id="bottom-sheet-handle"></div>
        <div class="bottom-sheet-content">
            <!-- Slicing Settings Section -->
            <div class="bottom-sheet-section">
                <h3>
                    <svg data-lucide="sliders-horizontal" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <line x1="21" y1="4" x2="14" y2="4"></line>
                        <line x1="10" y1="4" x2="3" y2="4"></line>
                        <line x1="21" y1="12" x2="12" y2="12"></line>
                        <line x1="8" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="20" x2="16" y2="20"></line>
                        <line x1="12" y1="20" x2="3" y2="20"></line>
                        <circle cx="12" cy="4" r="2"></circle>
                        <circle cx="10" cy="12" r="2"></circle>
                        <circle cx="14" cy="20" r="2"></circle>
                    </svg>
                    Slicing Settings
                </h3>
                <div id="mobile-slicing-content">
                    <!-- Content populated by JavaScript -->
                </div>
            </div>

            <!-- Background Settings Section -->
            <div class="bottom-sheet-section">
                <h3>
                    <svg data-lucide="image-play" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path d="m15 10-4 4 6 3-6 3v-6"></path>
                        <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                    </svg>
                    Full View Background
                </h3>
                <div id="mobile-background-content">
                    <!-- Content populated by JavaScript -->
                </div>
            </div>

            <!-- Video Settings Section -->
            <div class="bottom-sheet-section">
                <h3>
                    <svg data-lucide="video" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path d="m22 8-6 4 6 4V8Z"></path>
                        <rect width="14" height="12" x="2" y="6" rx="2" ry="2"></rect>
                    </svg>
                    Panning Video
                </h3>
                <div id="mobile-video-content">
                    <!-- Content populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Lightbox Modal -->
    <div id="lightbox" class="lightbox">
        <div class="lightbox-content">
            <img id="lightbox-image" class="lightbox-image" alt="" />
            
            <!-- Navigation -->
            <button id="lightbox-prev" class="lightbox-nav prev" aria-label="Previous image">
                <svg data-lucide="chevron-left" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <polyline points="15,18 9,12 15,6"></polyline>
                </svg>
            </button>
            
            <button id="lightbox-next" class="lightbox-nav next" aria-label="Next image">
                <svg data-lucide="chevron-right" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <polyline points="9,18 15,12 9,6"></polyline>
                </svg>
            </button>
            
            <!-- Close Button -->
            <button id="lightbox-close" class="lightbox-close" aria-label="Close lightbox">
                <svg data-lucide="x" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            
            <!-- Info Panel -->
            <div id="lightbox-info" class="lightbox-info">
                <div>
                    <span id="lightbox-title">Full View</span>
                    <span id="lightbox-resolution">1080×1350</span>
                </div>
                <a id="lightbox-download" class="lightbox-download" download>
                    <svg data-lucide="download" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7,10 12,15 17,10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Download This Slice
                </a>
            </div>
        </div>
    </div>
    
    <!-- Keyboard Shortcuts Modal -->
    <div id="shortcuts-modal" class="lightbox" aria-hidden="true">
        <div class="lightbox-content" role="dialog" aria-modal="true" aria-labelledby="shortcuts-title">
            <div class="glass-card p-6 max-w-lg w-[90vw]">
                <div class="glass-sheen"></div>
                <div class="flex items-center justify-between mb-4">
                    <h3 id="shortcuts-title" class="text-lg font-semibold gradient-title">Keyboard Shortcuts</h3>
                    <button id="shortcuts-close" class="lightbox-close" aria-label="Close">
                        <svg data-lucide="x" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm text-slate-300">
                    <div class="flex items-center justify-between bg-white/5 rounded-lg p-3 border border-white/10">
                        <span>Upload Image</span>
                        <kbd class="px-2 py-1 rounded bg-white/10 border border-white/20">U</kbd>
                    </div>
                    <div class="flex items-center justify-between bg-white/5 rounded-lg p-3 border border-white/10">
                        <span>Generate Slices</span>
                        <kbd class="px-2 py-1 rounded bg-white/10 border border-white/20">G</kbd>
                    </div>
                    <div class="flex items-center justify-between bg-white/5 rounded-lg p-3 border border-white/10">
                        <span>Generate Video</span>
                        <kbd class="px-2 py-1 rounded bg-white/10 border border-white/20">V</kbd>
                    </div>
                    <div class="flex items-center justify-between bg-white/5 rounded-lg p-3 border border-white/10">
                        <span>Open Settings (Mobile)</span>
                        <kbd class="px-2 py-1 rounded bg-white/10 border border-white/20">F</kbd>
                    </div>
                    <div class="flex items-center justify-between bg-white/5 rounded-lg p-3 border border-white/10">
                        <span>Show Shortcuts</span>
                        <kbd class="px-2 py-1 rounded bg-white/10 border border-white/20">?</kbd>
                    </div>
                    <div class="flex items-center justify-between bg-white/5 rounded-lg p-3 border border-white/10">
                        <span>Close/Back</span>
                        <kbd class="px-2 py-1 rounded bg-white/10 border border-white/20">Esc</kbd>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        lucide.createIcons();

        document.addEventListener('DOMContentLoaded', () => {
            // Detect system theme on first load and apply if not set
            try {
                const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
                const root = document.documentElement;
                if (!root.getAttribute('data-theme')) {
                    root.setAttribute('data-theme', prefersLight ? 'light' : 'dark');
                }
                // React to changes
                if (window.matchMedia) {
                    window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                        const isLight = e.matches;
                        if (!localStorage.getItem('themeOverride')) {
                            root.setAttribute('data-theme', isLight ? 'light' : 'dark');
                        }
                    });
                }
            } catch (_) {}
            // Surface any unhandled promise rejections to the UI to avoid stuck overlays
            window.addEventListener('unhandledrejection', (event) => {
                console.error('Unhandled promise rejection:', event.reason);
                try { hideLoading(); } catch(_) {}
                showError('An unexpected error occurred. Please try again.');
            });
            // --- DOM Elements ---
            const uploadArea = document.getElementById('upload-area');
            const fileInput = document.getElementById('file-input');
            const errorMessage = document.getElementById('error-message');
            const dismissError = document.getElementById('dismiss-error');
            const previewContainer = document.getElementById('preview-container');
            const previewImg = document.getElementById('preview-img');
            const originalSizeText = document.getElementById('original-size');
            const scaledSizeText = document.getElementById('scaled-size');
            const sliceCountText = document.getElementById('slice-count');
            const sliceResolutionText = document.getElementById('slice-resolution');
            const highResToggle = document.getElementById('high-res-toggle');
            const processBtn = document.getElementById('process-btn');
            const resetBtn = document.getElementById('reset-btn');
            const resultContainer = document.getElementById('result-container');
            const slicesPreview = document.getElementById('slices-preview');
            const downloadBtn = document.getElementById('download-btn');
            const processAnotherBtn = document.getElementById('process-another-btn');
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingText = document.getElementById('loading-text');
            const themeToggleBtn = document.getElementById('theme-toggle');
            const shortcutsBtn = document.getElementById('shortcuts-btn');
            const shortcutsModal = document.getElementById('shortcuts-modal');
            const shortcutsClose = document.getElementById('shortcuts-close');
            const downloadBtnText = downloadBtn.querySelector('.btn-text');
            const downloadBtnLoader = downloadBtn.querySelector('.btn-loader');
            // New BG Controls
            const fullViewSettings = document.getElementById('full-view-settings');
            const bgTypeRadios = document.querySelectorAll('input[name="bg-type"]');
            const blurControls = document.getElementById('blur-controls');
            const colorControls = document.getElementById('color-controls');
            const blurIntensity = document.getElementById('blur-intensity');
            const blurDownscale = document.getElementById('blur-downscale');
            const bgColorPicker = document.getElementById('bg-color-picker');
            const colorPalette = document.getElementById('color-palette');
            const gradientControls = document.getElementById('gradient-controls');
            const gradientType = document.getElementById('gradient-type');
            const gradientStops = document.getElementById('gradient-stops');
            const gradientBlend = document.getElementById('gradient-blend');
            const gradientPreview = document.getElementById('gradient-preview');
            const paletteFromImageBtn = document.getElementById('palette-from-image');
            let lastGradientPalette = [];

            // Track current video extension for downloads/zip
            let currentVideoExt = 'webm';
            // Video Controls
            const videoFormatSelect = document.getElementById('video-format');
            const videoEasingSelect = document.getElementById('video-easing');
            const easingDescription = document.getElementById('easing-description');
            const videoDurationInput = document.getElementById('video-duration');
            const videoFpsInput = document.getElementById('video-fps');
            const videoQualityInput = document.getElementById('video-quality');
            const videoQualityLabel = document.getElementById('video-quality-label');
            const generateVideoBtn = document.getElementById('generate-video-btn');
            const downloadVideoBtn = document.getElementById('download-video-btn');
            const panningVideo = document.getElementById('panning-video');
            const videoResultCard = document.getElementById('video-result-card');
            const uiFormatLabel = document.getElementById('video-format-label');
            const generateVideoBtnText = generateVideoBtn ? generateVideoBtn.querySelector('.btn-text') : null;
            const generateVideoBtnLoader = generateVideoBtn ? generateVideoBtn.querySelector('.btn-loader') : null;
            const downloadVideoBtnText = downloadVideoBtn ? downloadVideoBtn.querySelector('.btn-text') : null;
            const downloadVideoBtnLoader = downloadVideoBtn ? downloadVideoBtn.querySelector('.btn-loader') : null;
            
            // Enhanced UI Elements
            const uploadPreview = document.getElementById('upload-preview');
            const uploadPreviewImg = document.getElementById('upload-preview-img');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const successOverlay = document.getElementById('success-overlay');
            const bottomSheet = document.getElementById('bottom-sheet');
            const bottomSheetBackdrop = document.getElementById('bottom-sheet-backdrop');
            
            // Additional mobile-specific references
            const controls = document.getElementById('controls');
            const videoSettings = document.getElementById('video-settings');
            
            // Collapsible sections
            const fullViewToggle = document.getElementById('full-view-toggle');
            const fullViewContent = document.getElementById('full-view-content');
            const videoToggle = document.getElementById('video-toggle');
            const videoContent = document.getElementById('video-content');
            
            // --- State ---
            let originalImage = null;
            let slicedImages = [];
            let fullViewImage = null;
            let videoBlob = null;
            
            // --- Constants ---
            const ASPECT_RATIO = 4 / 5;
            const STANDARD_WIDTH = 1080;
            const STANDARD_HEIGHT = Math.round(STANDARD_WIDTH / ASPECT_RATIO);
            const MIN_SLICES = 2;
            const EXPORT_TYPE = 'image/png';

            // --- Enhanced UI Functions ---
            const showLoading = (message, showProgress = false) => { 
                loadingText.textContent = message; 
                loadingOverlay.classList.add('active');
                if (showProgress) {
                    progressContainer.classList.remove('hidden');
                    progressText.classList.remove('hidden');
                    updateProgress(0, 'Initializing...');
                } else {
                    progressContainer.classList.add('hidden');
                    progressText.classList.add('hidden');
                }
            };
            
            const hideLoading = () => {
                loadingOverlay.classList.remove('active');
                progressContainer.classList.add('hidden');
                progressText.classList.add('hidden');
            };
            
            const updateProgress = (percent, step) => {
                if (progressBar) {
                    progressBar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
                }
                if (progressText) {
                    progressText.textContent = step;
                }
            };
            
            const hideSuccessOverlay = () => {
                successOverlay.style.opacity = '0';
                successOverlay.style.pointerEvents = 'none';
            };
            
            const showSuccess = (message = 'Complete!') => {
                successOverlay.querySelector('p').textContent = message;
                successOverlay.style.opacity = '1';
                successOverlay.style.pointerEvents = 'auto';
                
                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate(60);
                }
                
                setTimeout(hideSuccessOverlay, 500);
            };

            const showSuccessWithPulse = (message = 'Complete!') => {
                const messageEl = successOverlay.querySelector('p');
                messageEl.textContent = message;
                
                successOverlay.style.opacity = '1';
                successOverlay.style.pointerEvents = 'auto';
                successOverlay.classList.add('success-pulse');
                
                // Enhanced haptic feedback for major completions
                if (navigator.vibrate) {
                    navigator.vibrate(80);
                }

                // Remove pulse class after animation
                setTimeout(() => { successOverlay.classList.remove('success-pulse'); hideSuccessOverlay(); }, 500);
            };

            const showButtonLoading = (button, text, loader) => { button.disabled = true; text.style.display = 'none'; loader.style.display = 'inline-block'; };
            const hideButtonLoading = (button, text, loader) => { button.disabled = false; text.style.display = 'flex'; loader.style.display = 'none'; };
            const showError = (message) => { 
                // Update primary error headline text
                const headline = errorMessage.querySelector('p, .font-semibold');
                if (headline) headline.textContent = message || 'Something went wrong';
                
                // Populate suggestions with contextual recovery tips
                const suggestions = errorMessage.querySelector('#error-suggestions');
                if (suggestions) {
                    suggestions.innerHTML = '';
                    const tips = [];
                    if (/clipboard/i.test(message || '')) {
                        tips.push('Allow clipboard access in your browser settings.');
                        tips.push('Try using the download button instead.');
                    } else if (/video|record|MediaRecorder/i.test(message || '')) {
                        tips.push('Try WebM format for widest support.');
                        tips.push('Lower FPS or quality to reduce system load.');
                    } else if (/image|load/i.test(message || '')) {
                        tips.push('Ensure the image is a valid JPG, PNG, WebP, or AVIF.');
                        tips.push('Try a smaller image or different file.');
                    } else {
                        tips.push('Refresh the page and try again.');
                        tips.push('Check browser console for details (F12).');
                    }
                    tips.forEach(t => {
                        const li = document.createElement('li');
                        li.textContent = t;
                        suggestions.appendChild(li);
                    });
                }
                
                errorMessage.style.display = 'block'; 
                errorMessage.scrollIntoView({ behavior: 'smooth' }); 
                
                if (navigator.vibrate) {
                    navigator.vibrate([200, 100, 200]);
                }
            };

            // Enhanced error handling functions
            const clearFieldError = (fieldElement) => {
                const container = fieldElement.closest('.field-container') || fieldElement.parentElement;
                const existingError = container.querySelector('.field-error');
                if (existingError) {
                    existingError.remove();
                }
                
                fieldElement.classList.remove('input-error', 'shake-error');
                
                // Remove error icon
                const errorIcon = container.querySelector('.error-icon');
                if (errorIcon) {
                    errorIcon.remove();
                }
            };

            const showFieldError = (fieldElement, message, options = {}) => {
                // Clear any existing error first
                clearFieldError(fieldElement);
                
                const container = fieldElement.closest('.field-container') || fieldElement.parentElement;
                
                // Add error styling to field
                fieldElement.classList.add('input-error');
                
                if (options.shake !== false) {
                    fieldElement.classList.add('shake-error');
                    setTimeout(() => fieldElement.classList.remove('shake-error'), 500);
                }
                
                // Create error message element
                const errorElement = document.createElement('span');
                errorElement.className = 'field-error';
                errorElement.textContent = message;
                
                // Add error icon if specified
                if (options.showIcon !== false) {
                    const iconElement = document.createElement('div');
                    iconElement.className = 'error-icon';
                    iconElement.innerHTML = `
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2zm0 14a1.25 1.25 0 100 2.5A1.25 1.25 0 0012 16zm-1-9h2v7h-2V7z"/>
                        </svg>
                    `;
                    container.style.position = 'relative';
                    container.appendChild(iconElement);
                }
                
                // Insert error message into the same container used for clearing
                container.appendChild(errorElement);
                
                // Auto-clear error after specified time
                if (options.autoClear !== false) {
                    setTimeout(() => {
                        clearFieldError(fieldElement);
                    }, options.duration || 5000);
                }
                
                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]);
                }
            };

            const showFieldSuccess = (fieldElement, options = {}) => {
                clearFieldError(fieldElement);
                fieldElement.classList.add('input-success');
                const container = fieldElement.closest('.field-container') || fieldElement.parentElement;
                if (container && !container.querySelector('.field-success')) {
                    const successEl = document.createElement('span');
                    successEl.className = 'field-success text-emerald-400 text-xs mt-1 block';
                    successEl.textContent = options.message || 'Looks good';
                    container.appendChild(successEl);
                    setTimeout(() => successEl.remove(), options.duration || 2000);
                }
                
                if (options.temporary !== false) {
                    setTimeout(() => {
                        fieldElement.classList.remove('input-success');
                    }, 2000);
                }
            };

            const validateImageFile = (file) => {
                if (!file.type.startsWith('image/')) {
                    return {
                        valid: false,
                        message: 'Please select a valid image file (JPG, PNG, WebP, AVIF)'
                    };
                }
                
                // Check file size (max 50MB)
                if (file.size > 50 * 1024 * 1024) {
                    return {
                        valid: false,
                        message: 'Image file size must be less than 50MB'
                    };
                }
                
                return { valid: true };
            };

            const validateWatermarkFile = (file) => {
                const type = (file && file.type) ? file.type.toLowerCase() : '';
                const name = (file && file.name) ? file.name.toLowerCase() : '';
                const isPngType = type.includes('png') || name.endsWith('.png');
                if (!isPngType) {
                    return {
                        valid: false,
                        message: 'Watermark must be a PNG file with transparency support'
                    };
                }
                
                // Check file size (max 10MB for watermark)
                if (file.size > 10 * 1024 * 1024) {
                    return {
                        valid: false,
                        message: 'Watermark file size must be less than 10MB'
                    };
                }
                
                return { valid: true };
            };

            const validateImageDimensions = (img) => {
                // Guard against invalid or zero dimensions
                if (!img || !img.width || !img.height) {
                    return {
                        valid: false,
                        message: 'Image dimensions could not be determined'
                    };
                }
                const aspectRatio = img.width / img.height;
                
                if (aspectRatio <= 1) {
                    return {
                        valid: false,
                        message: 'Panorama image must be wider than it is tall (landscape orientation required)'
                    };
                }
                
                if (img.width < 1000) {
                    return {
                        valid: false,
                        message: 'Image width must be at least 1000 pixels for proper slicing'
                    };
                }
                
                if (aspectRatio > 10) {
                    return {
                        valid: false,
                        message: 'Image aspect ratio too extreme. Maximum recommended ratio is 10:1'
                    };
                }
                
                return { valid: true };
            };

            const resetApp = () => {
                fileInput.value = '';
                previewContainer.style.display = 'none';
                resultContainer.style.display = 'none';
                errorMessage.style.display = 'none';
                uploadArea.style.display = 'block';
                originalImage = null;
                slicedImages = [];
                fullViewImage = null;
                previewImg.src = '';
                colorPalette.innerHTML = '';
                // Clear any gradient palette carried from a previous image
                lastGradientPalette = [];
                if (gradientPreview) gradientPreview.style.background = '';
                
                // Reset upload preview
                if (uploadPreview) {
                    uploadPreview.classList.remove('show');
                    uploadPreviewImg.src = '';
                }
                
                if (videoResultCard) {
                    videoResultCard.style.display = 'none';
                }
                if (panningVideo) {
                    if (panningVideo.src && panningVideo.src.startsWith('blob:')) {
                        try { URL.revokeObjectURL(panningVideo.src); } catch (_) {}
                    }
                    panningVideo.removeAttribute('src');
                    panningVideo.load();
                }
                videoBlob = null;
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
            
            // --- Event Listeners ---
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('drag-over');
            });
            uploadArea.addEventListener('dragleave', (e) => {
                if (e.relatedTarget && uploadArea.contains(e.relatedTarget)) return;
                uploadArea.classList.remove('drag-over');
            });
            // Single drop handler that also shows the upload preview
            // (Removed duplicate drop listener further below)
            
            fileInput.addEventListener('change', (e) => { 
                if (e.target.files.length) {
                    showUploadPreview(e.target.files[0]);
                    handleFile(e.target.files[0]); 
                }
            });
            
            // Enhanced drag and drop with preview
            uploadArea.addEventListener('drop', (e) => { 
                e.preventDefault(); 
                uploadArea.classList.remove('drag-over'); 
                if (e.dataTransfer.files.length) {
                    showUploadPreview(e.dataTransfer.files[0]);
                    handleFile(e.dataTransfer.files[0]); 
                }
            });
            processBtn.addEventListener('click', () => { 
                showLoading('Generating slices...', true); 
                setTimeout(async () => { 
                    try { 
                        await processImageWithProgress(); 
                    } catch (err) { 
                        console.error("Processing error:", err); 
                        showError("An unexpected error occurred during processing."); 
                        hideLoading();
                    } 
                }, 50); 
            });
            resetBtn.addEventListener('click', resetApp);
            processAnotherBtn.addEventListener('click', () => {
                // Clear current results and reset for new image
                resetApp();
                // Focus on upload area for better UX
                uploadArea.scrollIntoView({ behavior: 'smooth' });
                // Add subtle visual feedback
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            });
            dismissError.addEventListener('click', () => { errorMessage.style.display = 'none'; });
            downloadBtn.addEventListener('click', () => { showButtonLoading(downloadBtn, downloadBtnText, downloadBtnLoader); setTimeout(async () => { try { await downloadZip(); } catch (error) { console.error('Error creating zip:', error); showError('There was a problem creating your zip file.'); } finally { hideButtonLoading(downloadBtn, downloadBtnText, downloadBtnLoader); } }, 50); });
            highResToggle.addEventListener('change', () => { if (originalImage) { updateImageDetails(); updateQualityLabel(); } });
            if (videoFpsInput) {
                videoFpsInput.addEventListener('input', () => updateQualityLabel());
            }
            // Video listeners
            if (videoQualityInput) {
                const chip = document.createElement('div');
                chip.className = 'range-value-chip hidden';
                videoQualityInput.parentElement.style.position = 'relative';
                videoQualityInput.parentElement.appendChild(chip);
                const updateChip = () => {
                    const min = parseInt(videoQualityInput.min || '10', 10);
                    const max = parseInt(videoQualityInput.max || '100', 10);
                    const val = parseInt(videoQualityInput.value || '80', 10);
                    const pct = (val - min) / (max - min);
                    const rect = videoQualityInput.getBoundingClientRect();
                    const x = rect.width * pct;
                    chip.style.left = `${x}px`;
                    chip.textContent = `${val}`;
                };
                videoQualityInput.addEventListener('input', () => { updateQualityLabel(); chip.classList.remove('hidden'); updateChip(); });
                videoQualityInput.addEventListener('change', () => { chip.classList.add('hidden'); });
            }
            if (generateVideoBtn) {
                generateVideoBtn.addEventListener('click', async () => {
                    if (!originalImage) { showError('Please upload a panorama image first.'); return; }
                    // Show global loading with progress similar to slices
                    showLoading('Generating video...', true);
                    showButtonLoading(generateVideoBtn, generateVideoBtnText, generateVideoBtnLoader);
                    try {
                        updateProgress(5, 'Preparing canvas and encoder...');
                        await new Promise(r => setTimeout(r, 50));
                        await generatePanningVideo();
                        updateProgress(100, 'Finalizing video...');
                        await new Promise(r => setTimeout(r, 200));
                        hideLoading();
                        showSuccessWithPulse('Video generated successfully!');
                    } catch (err) {
                        console.error('Video generation error:', err);
                        showError('Video generation failed. Your browser may not support recording.');
                        hideLoading();
                    } finally {
                        hideButtonLoading(generateVideoBtn, generateVideoBtnText, generateVideoBtnLoader);
                    }
                });
            }
            if (downloadVideoBtn) {
                downloadVideoBtn.addEventListener('click', async () => {
                    if (!videoBlob) { showError('No video available to download.'); return; }
                    showButtonLoading(downloadVideoBtn, downloadVideoBtnText, downloadVideoBtnLoader);
                    try {
                        const baseName = originalImage?.name?.split('.').slice(0, -1).join('.') || 'pano';
                        const a = document.createElement('a');
                        const url = URL.createObjectURL(videoBlob);
                        a.href = url;
                        const ext = currentVideoExt || ((uiFormatLabel?.textContent || 'WebM').toLowerCase() === 'mp4' ? 'mp4' : 'webm');
                        a.download = `${baseName}_panning.${ext}`;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        setTimeout(() => URL.revokeObjectURL(url), 1000);
                    } finally {
                        hideButtonLoading(downloadVideoBtn, downloadVideoBtnText, downloadVideoBtnLoader);
                    }
                });
            }
            if (videoFormatSelect) {
                videoFormatSelect.addEventListener('change', () => updateQualityLabel());
            }
            if (videoEasingSelect) {
                videoEasingSelect.addEventListener('change', () => updateEasingDescription());
            }

            // --- Collapsible Sections ---
            // Theme toggle with override + smooth transition
            const setTheme = (theme, save = true) => {
                const root = document.documentElement;
                root.style.transition = 'color 250ms ease, background-color 250ms ease';
                root.setAttribute('data-theme', theme);
                if (save) localStorage.setItem('themeOverride', theme);
                setTimeout(() => { root.style.transition = ''; }, 300);
            };
            const storedTheme = localStorage.getItem('themeOverride');
            if (storedTheme) setTheme(storedTheme, false);
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', () => {
                    const current = document.documentElement.getAttribute('data-theme') || 'dark';
                    setTheme(current === 'light' ? 'dark' : 'light');
                });
            }
            const setupCollapsible = (toggle, content) => {
                if (!toggle || !content) return;
                    const icon = toggle.querySelector('.expand-icon');
                const isExpanded = () => content.classList.contains('expanded');
                const setExpanded = (expanded) => {
                    if (expanded) {
                        content.classList.add('expanded');
                        icon?.classList.add('expanded');
                        // Set explicit height for transition, then remove to allow intrinsic growth
                        const full = content.scrollHeight + 'px';
                        content.style.maxHeight = full;
                        content.style.transition = 'max-height 350ms cubic-bezier(0.4, 0, 0.2, 1)';
                        // After transition, allow natural expansion without clipping
                        setTimeout(() => { if (content.classList.contains('expanded')) content.style.maxHeight = 'none'; }, 360);
                    } else {
                        content.classList.remove('expanded');
                        icon?.classList.remove('expanded');
                        content.style.maxHeight = '0px';
                        content.style.transition = 'max-height 350ms cubic-bezier(0.4, 0, 0.2, 1)';
                    }
                };
                toggle.addEventListener('click', () => {
                    setExpanded(!isExpanded());
                    if (navigator.vibrate) navigator.vibrate(50);
                });
                // Initialize collapsed
                setExpanded(false);
            };

            setupCollapsible(fullViewToggle, fullViewContent);
            setupCollapsible(videoToggle, videoContent);

            // --- Shortcuts Modal helpers ---
            const openShortcuts = () => {
                if (!shortcutsModal) return;
                shortcutsModal.classList.add('open');
            };
            const closeShortcuts = () => {
                if (!shortcutsModal) return;
                shortcutsModal.classList.remove('open');
            };
            if (shortcutsBtn) shortcutsBtn.addEventListener('click', openShortcuts);
            if (shortcutsClose) shortcutsClose.addEventListener('click', closeShortcuts);
            if (shortcutsModal) shortcutsModal.addEventListener('click', (e) => { if (e.target === shortcutsModal) closeShortcuts(); });

            // --- Enhanced File Upload ---
            const showUploadPreview = (file) => {
                if (!uploadPreview || !uploadPreviewImg) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    uploadPreviewImg.src = e.target.result;
                    uploadPreview.classList.add('show');
                    // Also set the large preview image for zoom
                    const large = document.getElementById('preview-img');
                    if (large) large.src = e.target.result;
                };
                reader.readAsDataURL(file);
            };

            // New BG Control Listeners
            bgTypeRadios.forEach(radio => radio.addEventListener('change', (e) => {
                const type = e.target.value;
                const isBlur = type === 'blur';
                const isColor = type === 'color';
                const isGradient = type === 'gradient';

                blurControls.style.display = isBlur ? 'block' : 'none';
                colorControls.style.display = isColor ? 'block' : 'none';
                if (gradientControls) gradientControls.style.display = isGradient ? 'block' : 'none';

                if (originalImage) updateFullViewPreview();
            }));
            blurIntensity.addEventListener('input', () => { if (originalImage) updateFullViewPreview(); });
            if (blurDownscale) blurDownscale.addEventListener('input', () => { if (originalImage) updateFullViewPreview(); });
            bgColorPicker.addEventListener('input', () => { if (originalImage) updateFullViewPreview(); });
            if (gradientType) gradientType.addEventListener('change', () => { if (originalImage) { if (!lastGradientPalette.length) lastGradientPalette = extractPaletteKMeans(originalImage.element, parseInt(gradientStops?.value || '4', 10)); updateGradientPreview(lastGradientPalette); updateFullViewPreview(); } });
            if (gradientStops) gradientStops.addEventListener('input', () => { if (originalImage) { lastGradientPalette = extractPaletteKMeans(originalImage.element, parseInt(gradientStops?.value || '4', 10)); updateGradientPreview(lastGradientPalette); updateFullViewPreview(); } });
            if (gradientBlend) gradientBlend.addEventListener('change', () => { if (originalImage) { if (!lastGradientPalette.length) lastGradientPalette = extractPaletteKMeans(originalImage.element, parseInt(gradientStops?.value || '4', 10)); updateGradientPreview(lastGradientPalette); updateFullViewPreview(); } });
            if (paletteFromImageBtn) paletteFromImageBtn.addEventListener('click', (e) => {
                e.preventDefault();
                if (originalImage) {
                    const colors = extractPaletteKMeans(originalImage.element, parseInt(gradientStops?.value || '4', 10));
                    updateGradientPreview(colors);
                    if (originalImage) updateFullViewPreview();
                }
            });

            // Change File button handler
            const changeFileBtn = document.getElementById('change-file-btn');
            if (changeFileBtn && fileInput) {
                changeFileBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    fileInput.click();
                });
            }

            // --- Watermark Functionality ---
            const watermarkInput = document.getElementById('watermark-input');
            const watermarkUploadBtn = document.getElementById('watermark-upload-btn');
            const watermarkRemoveBtn = document.getElementById('watermark-remove-btn');
            const watermarkFilename = document.getElementById('watermark-filename');
            const watermarkPreview = document.getElementById('watermark-preview');
            const watermarkPreviewImg = document.getElementById('watermark-preview-img');
            const watermarkSettings = document.getElementById('watermark-settings');
            const watermarkOpacity = document.getElementById('watermark-opacity');
            const watermarkOpacityLabel = document.getElementById('watermark-opacity-label');
            const watermarkSize = document.getElementById('watermark-size');
            const watermarkSizeLabel = document.getElementById('watermark-size-label');
            const watermarkPositionRadios = document.querySelectorAll('input[name="watermark-position"]');
            const textWatermarkPositionRadios = document.querySelectorAll('input[name="text-watermark-position"]');
            const textWatermarkOpacity = document.getElementById('text-watermark-opacity');
            const textWatermarkOpacityLabel = document.getElementById('text-watermark-opacity-label');
            const textWatermarkSize = document.getElementById('text-watermark-size');
            const textWatermarkSizeLabel = document.getElementById('text-watermark-size-label');
            const watermarkTypeRadios = document.querySelectorAll('input[name="watermark-type"]');
            const textWatermarkControls = document.getElementById('text-watermark-controls');
            const imageWatermarkControls = document.getElementById('image-watermark-controls');
            const watermarkText = document.getElementById('watermark-text');
            const watermarkFontSize = document.getElementById('watermark-font-size');
            const watermarkFontSizeLabel = document.getElementById('watermark-font-size-label');
            const watermarkTextColor = document.getElementById('watermark-text-color');
            const watermarkFontWeight = document.getElementById('watermark-font-weight');
            const watermarkTextStroke = document.getElementById('watermark-text-stroke');

            let watermarkImage = null;
            let currentWatermarkType = 'none';

            // Watermark upload
            if (watermarkUploadBtn) {
                watermarkUploadBtn.addEventListener('click', () => {
                    watermarkInput.click();
                });
            }

            if (watermarkInput) {
                watermarkInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    // Validate watermark file
                    const watermarkValidation = validateWatermarkFile(file);
                    if (!watermarkValidation.valid) {
                        showFieldError(watermarkInput, watermarkValidation.message);
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            watermarkImage = img;
                            watermarkFilename.textContent = file.name;
                            watermarkPreviewImg.src = event.target.result;
                            watermarkPreview.classList.remove('hidden');
                            watermarkRemoveBtn.classList.remove('hidden');
                            watermarkSettings.classList.remove('hidden');
                            
                            if (originalImage) {
                                updateFullViewPreview();
                            }
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            }

            // Watermark remove
            if (watermarkRemoveBtn) {
                watermarkRemoveBtn.addEventListener('click', () => {
                    watermarkImage = null;
                    watermarkInput.value = '';
                    watermarkFilename.textContent = 'No file selected';
                    watermarkPreview.classList.add('hidden');
                    watermarkRemoveBtn.classList.add('hidden');
                    watermarkSettings.classList.add('hidden');
                    
                    if (originalImage) {
                        updateFullViewPreview();
                    }
                });
            }

            // Watermark settings
            if (watermarkOpacity) {
                watermarkOpacity.addEventListener('input', () => {
                    watermarkOpacityLabel.textContent = `${watermarkOpacity.value}%`;
                    if (originalImage && watermarkImage) {
                        updateFullViewPreview();
                    }
                });
            }

            if (watermarkSize) {
                watermarkSize.addEventListener('input', () => {
                    watermarkSizeLabel.textContent = `${watermarkSize.value}%`;
                    if (originalImage && watermarkImage) {
                        updateFullViewPreview();
                    }
                });
            }

            watermarkPositionRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    if (originalImage && watermarkImage) {
                        updateFullViewPreview();
                    }
                });
            });

            // Text watermark position controls
            textWatermarkPositionRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    if (originalImage && currentWatermarkType === 'text') {
                        updateFullViewPreview();
                    }
                });
            });

            // Text watermark opacity and size controls
            if (textWatermarkOpacity) {
                textWatermarkOpacity.addEventListener('input', () => {
                    textWatermarkOpacityLabel.textContent = `${textWatermarkOpacity.value}%`;
                    if (originalImage && currentWatermarkType === 'text') {
                        updateFullViewPreview();
                    }
                });
            }

            if (textWatermarkSize) {
                textWatermarkSize.addEventListener('input', () => {
                    textWatermarkSizeLabel.textContent = `${textWatermarkSize.value}%`;
                    if (originalImage && currentWatermarkType === 'text') {
                        updateFullViewPreview();
                    }
                });
            }

            // Update position radio styling
            const updateWatermarkPositionStyling = () => {
                watermarkPositionRadios.forEach(radio => {
                    const label = radio.closest('label');
                    if (radio.checked) {
                        label.style.borderColor = '#667eea';
                        label.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                        label.style.color = '#667eea';
                    } else {
                        label.style.borderColor = '#475569';
                        label.style.backgroundColor = 'transparent';
                        label.style.color = 'rgba(248, 250, 252, 0.8)';
                    }
                });
            };

            watermarkPositionRadios.forEach(radio => {
                radio.addEventListener('change', updateWatermarkPositionStyling);
            });

            // Initialize position styling
            updateWatermarkPositionStyling();

            // Watermark type handling
            watermarkTypeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    currentWatermarkType = e.target.value;
                    
                    // Hide all controls first
                    textWatermarkControls.classList.add('hidden');
                    imageWatermarkControls.classList.add('hidden');
                    watermarkSettings.classList.add('hidden');
                    
                    // Show appropriate controls (avoid duplicate sections)
                    if (currentWatermarkType === 'text') {
                        textWatermarkControls.classList.remove('hidden');
                        watermarkSettings.classList.add('hidden');
                    } else if (currentWatermarkType === 'image') {
                        imageWatermarkControls.classList.remove('hidden');
                        if (watermarkImage) {
                            watermarkSettings.classList.remove('hidden');
                        }
                    }
                    
                    // Update preview if image is loaded
                    if (originalImage) {
                        updateFullViewPreview();
                    }
                    
                    updateWatermarkTypeRadioStyling();
                });
            });

            // Text watermark controls
            if (watermarkText) {
                watermarkText.addEventListener('input', () => {
                    if (originalImage && currentWatermarkType === 'text') {
                        updateFullViewPreview();
                    }
                });
            }

            if (watermarkFontSize) {
                watermarkFontSize.addEventListener('input', () => {
                    watermarkFontSizeLabel.textContent = `${watermarkFontSize.value}px`;
                    if (originalImage && currentWatermarkType === 'text') {
                        updateFullViewPreview();
                    }
                });
            }

            if (watermarkTextColor) {
                watermarkTextColor.addEventListener('input', () => {
                    if (originalImage && currentWatermarkType === 'text') {
                        updateFullViewPreview();
                    }
                });
            }

            if (watermarkFontWeight) {
                watermarkFontWeight.addEventListener('change', () => {
                    if (originalImage && currentWatermarkType === 'text') {
                        updateFullViewPreview();
                    }
                });
            }

            if (watermarkTextStroke) {
                watermarkTextStroke.addEventListener('change', () => {
                    if (originalImage && currentWatermarkType === 'text') {
                        updateFullViewPreview();
                    }
                });
            }

            // Update type radio styling
            const updateWatermarkTypeRadioStyling = () => {
                watermarkTypeRadios.forEach(radio => {
                    const label = radio.closest('label');
                    if (radio.checked) {
                        label.style.borderColor = '#667eea';
                        label.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                        label.style.color = '#667eea';
                    } else {
                        label.style.borderColor = '#475569';
                        label.style.backgroundColor = 'transparent';
                        label.style.color = 'rgba(248, 250, 252, 0.8)';
                    }
                });
            };

            watermarkTypeRadios.forEach(radio => {
                radio.addEventListener('change', updateWatermarkTypeRadioStyling);
            });

            // Initialize defaults: show text watermark controls only (no generic duplicate)
            const defaultType = document.querySelector('input[name="watermark-type"][value="text"]');
            if (defaultType) {
                defaultType.checked = true;
                currentWatermarkType = 'text';
                textWatermarkControls.classList.remove('hidden');
                watermarkSettings.classList.add('hidden');
            }
            updateWatermarkTypeRadioStyling();

            // --- State Persistence ---
            const STORAGE_KEY = 'panorama_slicer_settings';
            
            const saveSettings = () => {
                const settings = {
                    // Slicing settings
                    highRes: highResToggle?.checked || false,
                    
                    // Background settings
                    bgType: document.querySelector('input[name="bg-type"]:checked')?.value || 'blur',
                    blurIntensity: blurIntensity?.value || '10',
                    blurDownscale: blurDownscale?.value || '35',
                    bgColor: bgColorPicker?.value || '#FFFFFF',
                    gradientType: gradientType?.value || 'radial',
                    gradientStops: gradientStops?.value || '4',
                    gradientBlend: gradientBlend?.value || 'normal',
                    
                    // Video settings
                    videoDuration: videoDurationInput?.value || '10',
                    videoFps: videoFpsInput?.value || '30',
                    videoQuality: videoQualityInput?.value || '80',
                    videoFormat: videoFormatSelect?.value || 'webm',
                    videoEasing: videoEasingSelect?.value || 'linear',
                    
                    // Watermark settings
                    watermarkType: document.querySelector('input[name="watermark-type"]:checked')?.value || 'none',
                    watermarkOpacity: watermarkOpacity?.value || '70',
                    watermarkSize: watermarkSize?.value || '15',
                    watermarkPosition: document.querySelector('input[name="watermark-position"]:checked')?.value || 'bottom-right',
                    textWatermarkOpacity: textWatermarkOpacity?.value || '70',
                    textWatermarkSize: textWatermarkSize?.value || '15',
                    textWatermarkPosition: document.querySelector('input[name="text-watermark-position"]:checked')?.value || 'bottom-right',
                    watermarkText: watermarkText?.value || '',
                    watermarkFontSize: watermarkFontSize?.value || '24',
                    watermarkTextColor: watermarkTextColor?.value || '#FFFFFF',
                    watermarkFontWeight: watermarkFontWeight?.value || 'bold',
                    watermarkTextStroke: watermarkTextStroke?.value || 'thin',
                    
                    // Metadata
                    lastSaved: Date.now(),
                    version: '1.0'
                };
                
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
                } catch (e) {
                    console.warn('Failed to save settings to localStorage:', e);
                }
            };
            
            const loadSettings = () => {
                try {
                    const savedSettings = localStorage.getItem(STORAGE_KEY);
                    if (!savedSettings) return;
                    
                    const settings = JSON.parse(savedSettings);
                    
                    // Load slicing settings
                    if (highResToggle && typeof settings.highRes === 'boolean') {
                        highResToggle.checked = settings.highRes;
                    }
                    
                    // Load background settings
                    if (settings.bgType) {
                        const bgRadio = document.querySelector(`input[name="bg-type"][value="${settings.bgType}"]`);
                        if (bgRadio) {
                            bgRadio.checked = true;
                            // Dispatch change so all dependent UI and listeners update cohesively
                            try { bgRadio.dispatchEvent(new Event('change', { bubbles: true })); } catch(_) {}
                        }
                    }
                    
                    if (blurIntensity && settings.blurIntensity) {
                        blurIntensity.value = settings.blurIntensity;
                    }
                    if (blurDownscale && settings.blurDownscale) {
                        blurDownscale.value = settings.blurDownscale;
                    }
                    
                    if (bgColorPicker && settings.bgColor) {
                        bgColorPicker.value = settings.bgColor;
                    }

                    if (gradientType && settings.gradientType) {
                        gradientType.value = settings.gradientType;
                    }
                    if (gradientStops && settings.gradientStops) {
                        gradientStops.value = settings.gradientStops;
                    }
                    if (gradientBlend && settings.gradientBlend) {
                        gradientBlend.value = settings.gradientBlend;
                    }
                    
                    // Load video settings
                    if (videoDurationInput && settings.videoDuration) {
                        videoDurationInput.value = settings.videoDuration;
                    }
                    
                    if (videoFpsInput && settings.videoFps) {
                        videoFpsInput.value = settings.videoFps;
                    }
                    
                    if (videoQualityInput && settings.videoQuality) {
                        videoQualityInput.value = settings.videoQuality;
                        updateQualityLabel();
                    }
                    
                    if (videoFormatSelect && settings.videoFormat) {
                        videoFormatSelect.value = settings.videoFormat;
                    }
                    
                    if (videoEasingSelect && settings.videoEasing) {
                        videoEasingSelect.value = settings.videoEasing;
                        updateEasingDescription();
                    }
                    
                    // Load watermark settings
                    if (settings.watermarkType) {
                        const typeRadio = document.querySelector(`input[name="watermark-type"][value="${settings.watermarkType}"]`);
                        if (typeRadio) {
                            typeRadio.checked = true;
                            currentWatermarkType = settings.watermarkType;
                            updateWatermarkTypeRadioStyling();
                            // Drive UI through the same handler logic
                            try { typeRadio.dispatchEvent(new Event('change', { bubbles: true })); } catch(_) {}
                        }
                    }
                    
                    if (watermarkOpacity && settings.watermarkOpacity) {
                        watermarkOpacity.value = settings.watermarkOpacity;
                        watermarkOpacityLabel.textContent = `${settings.watermarkOpacity}%`;
                    }
                    
                    if (watermarkSize && settings.watermarkSize) {
                        watermarkSize.value = settings.watermarkSize;
                        watermarkSizeLabel.textContent = `${settings.watermarkSize}%`;
                    }
                    
                    if (settings.watermarkPosition) {
                        const positionRadio = document.querySelector(`input[name="watermark-position"][value="${settings.watermarkPosition}"]`);
                        if (positionRadio) {
                            positionRadio.checked = true;
                            updateWatermarkPositionStyling();
                        }
                    }

                    if (settings.textWatermarkOpacity && textWatermarkOpacity) {
                        textWatermarkOpacity.value = settings.textWatermarkOpacity;
                        textWatermarkOpacityLabel.textContent = `${settings.textWatermarkOpacity}%`;
                    }

                    if (settings.textWatermarkSize && textWatermarkSize) {
                        textWatermarkSize.value = settings.textWatermarkSize;
                        textWatermarkSizeLabel.textContent = `${settings.textWatermarkSize}%`;
                    }

                    if (settings.textWatermarkPosition) {
                        const textPositionRadio = document.querySelector(`input[name="text-watermark-position"][value="${settings.textWatermarkPosition}"]`);
                        if (textPositionRadio) {
                            textPositionRadio.checked = true;
                            try { textPositionRadio.dispatchEvent(new Event('change', { bubbles: true })); } catch(_) {}
                        }
                    }
                    
                    // Load text watermark settings
                    if (watermarkText && settings.watermarkText) {
                        watermarkText.value = settings.watermarkText;
                    }
                    
                    if (watermarkFontSize && settings.watermarkFontSize) {
                        watermarkFontSize.value = settings.watermarkFontSize;
                        watermarkFontSizeLabel.textContent = `${settings.watermarkFontSize}px`;
                    }
                    
                    if (watermarkTextColor && settings.watermarkTextColor) {
                        watermarkTextColor.value = settings.watermarkTextColor;
                    }
                    
                    if (watermarkFontWeight && settings.watermarkFontWeight) {
                        watermarkFontWeight.value = settings.watermarkFontWeight;
                    }
                    
                    if (watermarkTextStroke && settings.watermarkTextStroke) {
                        watermarkTextStroke.value = settings.watermarkTextStroke;
                    }
                    
                    // Update preview if an image is already loaded
                    if (originalImage) updateFullViewPreview();
                } catch (e) {
                    console.warn('Failed to load settings from localStorage:', e);
                }
            };
            
            // Auto-save settings when they change
            const setupAutoSave = () => {
                // Slicing settings
                if (highResToggle) {
                    highResToggle.addEventListener('change', saveSettings);
                }
                
                // Background settings
                bgTypeRadios.forEach(radio => {
                    radio.addEventListener('change', saveSettings);
                });
                
                if (blurIntensity) {
                    blurIntensity.addEventListener('change', saveSettings);
                }
                if (blurDownscale) {
                    blurDownscale.addEventListener('change', saveSettings);
                }
                
                if (bgColorPicker) {
                    bgColorPicker.addEventListener('change', saveSettings);
                }
                if (gradientType) {
                    gradientType.addEventListener('change', saveSettings);
                }
                if (gradientStops) {
                    gradientStops.addEventListener('change', saveSettings);
                }
                if (gradientBlend) {
                    gradientBlend.addEventListener('change', saveSettings);
                }
                
                // Video settings
                if (videoDurationInput) {
                    videoDurationInput.addEventListener('change', saveSettings);
                }
                
                if (videoFpsInput) {
                    videoFpsInput.addEventListener('change', saveSettings);
                }
                
                if (videoQualityInput) {
                    videoQualityInput.addEventListener('change', saveSettings);
                }
                
                if (videoFormatSelect) {
                    videoFormatSelect.addEventListener('change', saveSettings);
                }
                
                if (videoEasingSelect) {
                    videoEasingSelect.addEventListener('change', saveSettings);
                }
                
                // Watermark settings
                if (watermarkOpacity) {
                    watermarkOpacity.addEventListener('change', saveSettings);
                }
                
                if (watermarkSize) {
                    watermarkSize.addEventListener('change', saveSettings);
                }
                
                watermarkPositionRadios.forEach(radio => {
                    radio.addEventListener('change', saveSettings);
                });
                
                textWatermarkPositionRadios.forEach(radio => {
                    radio.addEventListener('change', saveSettings);
                });
                
                if (textWatermarkOpacity) {
                    textWatermarkOpacity.addEventListener('change', saveSettings);
                }
                
                if (textWatermarkSize) {
                    textWatermarkSize.addEventListener('change', saveSettings);
                }
                
                // Watermark type settings
                watermarkTypeRadios.forEach(radio => {
                    radio.addEventListener('change', saveSettings);
                });
                
                // Text watermark settings
                if (watermarkText) {
                    watermarkText.addEventListener('input', saveSettings);
                }
                
                if (watermarkFontSize) {
                    watermarkFontSize.addEventListener('change', saveSettings);
                }
                
                if (watermarkTextColor) {
                    watermarkTextColor.addEventListener('change', saveSettings);
                }
                
                if (watermarkFontWeight) {
                    watermarkFontWeight.addEventListener('change', saveSettings);
                }
                
                if (watermarkTextStroke) {
                    watermarkTextStroke.addEventListener('change', saveSettings);
                }
            };

            // Load settings on page load
            loadSettings();
            
            // Setup auto-save
            setupAutoSave();

            // --- Theme Toggle Functionality ---
            const themeToggle = document.getElementById('theme-toggle');
            const themeIconDark = document.getElementById('theme-icon-dark');
            const themeIconLight = document.getElementById('theme-icon-light');
            
            let currentTheme = localStorage.getItem('theme') || 'dark';
            
            const applyTheme = (theme) => {
                if (theme === 'light') {
                    document.documentElement.setAttribute('data-theme', 'light');
                    themeIconDark.classList.add('hidden');
                    themeIconLight.classList.remove('hidden');
                } else {
                    document.documentElement.removeAttribute('data-theme');
                    themeIconDark.classList.remove('hidden');
                    themeIconLight.classList.add('hidden');
                }
            };
            
            const toggleTheme = () => {
                currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
                applyTheme(currentTheme);
                localStorage.setItem('theme', currentTheme);
                
                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            };
            
            // Initialize theme
            applyTheme(currentTheme);
            
            // Theme toggle event listener
            if (themeToggle) {
                themeToggle.addEventListener('click', toggleTheme);
            }

            // --- Copy to Clipboard Functionality ---
            const copyImageToClipboard = async (dataURL, buttonElement, isFullView = false) => {
                if (!navigator.clipboard || !navigator.clipboard.write) {
                    // Fallback: trigger a download instead of failing
                    try {
                        const link = document.createElement('a');
                        link.href = dataURL;
                        link.download = isFullView ? 'full_view.png' : 'slice.png';
                        document.body.appendChild(link);
                        link.click();
                        link.remove();
                        showSuccess(isFullView ? 'Full view downloaded.' : 'Slice downloaded.');
                    } catch (_) {
                    showError('Clipboard copying is not supported in this browser.');
                    }
                    return;
                }

                try {
                    // Update button state to show copying
                    buttonElement.classList.add('copying');
                    const originalHTML = buttonElement.innerHTML;
                    buttonElement.innerHTML = `
                        <svg data-lucide="loader-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" class="animate-spin">
                            <path d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            <path d="M9 12l2 2 4-4"></path>
                        </svg>
                    `;

                    // Convert data URL to blob
                    const response = await fetch(dataURL);
                    const blob = await response.blob();

                    // Create clipboard item
                    const clipboardItem = new ClipboardItem({
                        [blob.type]: blob
                    });

                    // Write to clipboard
                    await navigator.clipboard.write([clipboardItem]);

                    // Update button to show success
                    buttonElement.classList.remove('copying');
                    buttonElement.classList.add('copied');
                    buttonElement.innerHTML = `
                        <svg data-lucide="check" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <polyline points="20,6 9,17 4,12"></polyline>
                        </svg>
                    `;

                    // Show success message
                    const imageType = isFullView ? 'Full view' : 'Slice';
                    showSuccess(`${imageType} copied to clipboard!`);

                    // Haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate([50, 50, 50]);
                    }

                    // Reset button after 2 seconds (no global icon re-render)
                    setTimeout(() => {
                        buttonElement.classList.remove('copied');
                        buttonElement.innerHTML = originalHTML;
                    }, 2000);

                } catch (error) {
                    console.error('Failed to copy image to clipboard:', error);
                    
                    // Reset button state
                    buttonElement.classList.remove('copying');
                    const originalHTML = buttonElement.innerHTML;
                    buttonElement.innerHTML = `
                        <svg data-lucide="x" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    `;

                    // Show error message
                    if (error.name === 'NotAllowedError') {
                        showError('Clipboard access denied. Please allow clipboard permissions.');
                    } else if (error.name === 'NotSupportedError') {
                        showError('Image copying is not supported in this browser.');
                    } else {
                        showError('Failed to copy image to clipboard.');
                    }

                    // Reset button after 2 seconds (no global icon re-render)
                    setTimeout(() => {
                        buttonElement.innerHTML = originalHTML;
                    }, 2000);
                }
            };

            // Build a static watermark settings object to avoid per-frame DOM reads
            const collectWatermarkSettings = () => {
                const type = currentWatermarkType;
                if (type === 'none') return { type: 'none' };
                if (type === 'image') {
                    if (!watermarkImage || !watermarkImage.width || !watermarkImage.height) return { type: 'none' };
                    return {
                        type: 'image',
                        image: watermarkImage,
                        opacity: parseInt(watermarkOpacity?.value || '70', 10) / 100,
                        imageSizePercent: parseInt(watermarkSize?.value || '15', 10) / 100,
                        position: document.querySelector('input[name="watermark-position"]:checked')?.value || 'bottom-right',
                    };
                }
                // text watermark
                const text = watermarkText?.value?.trim() || '';
                if (!text) return { type: 'none' };
                return {
                    type: 'text',
                    text,
                    opacity: parseInt(textWatermarkOpacity?.value || '70', 10) / 100,
                    position: document.querySelector('input[name="text-watermark-position"]:checked')?.value || 'bottom-right',
                    fontSizePxBase: parseInt(watermarkFontSize?.value || '24', 10),
                    fontWeight: watermarkFontWeight?.value || 'bold',
                    textColor: watermarkTextColor?.value || '#FFFFFF',
                    strokeType: watermarkTextStroke?.value || 'none',
                    // Keep available even if currently unused by font-size path
                    textSizePercent: parseInt(textWatermarkSize?.value || '15', 10) / 100,
                };
            };

            // Skeleton helpers
            const showPreviewSkeleton = () => {
                const cont = document.getElementById('preview-container');
                if (!cont) return;
                const sk = document.createElement('div');
                sk.id = 'preview-skeleton';
                sk.className = 'skeleton h-[200px] rounded-xl mb-2';
                cont.querySelector('.p-6')?.prepend(sk);
            };
            const hidePreviewSkeleton = () => {
                document.getElementById('preview-skeleton')?.remove();
            };

            // Watermark application function (can consume precomputed settings)
            const applyWatermark = (canvas, ctx, settings) => {
                const type = settings?.type ?? currentWatermarkType;
                if (type === 'none') return;
                
                // Validate image/text availability if needed
                if (type === 'image') {
                    const img = settings?.image ?? watermarkImage;
                    if (!img || !img.width || !img.height) return;
                } else if (type === 'text') {
                    const text = settings?.text ?? watermarkText?.value?.trim();
                    if (!text) return;
                }

                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                
                const margin = Math.min(canvasWidth, canvasHeight) * 0.02; // 2% margin
                
                ctx.save();
                const opacity = settings?.opacity ?? (
                    type === 'text'
                        ? (parseInt(textWatermarkOpacity?.value || '70', 10) / 100)
                        : (parseInt(watermarkOpacity?.value || '70', 10) / 100)
                );
                ctx.globalAlpha = opacity;
                
                if (type === 'image') {
                    const img = settings?.image ?? watermarkImage;
                    const sizePercent = settings?.imageSizePercent ?? (parseInt(watermarkSize?.value || '15', 10) / 100);
                    // Calculate watermark dimensions for image
                    const maxSize = Math.min(canvasWidth, canvasHeight) * sizePercent;
                    const aspectRatio = img.width / img.height;
                    
                    let watermarkWidth, watermarkHeight;
                    if (aspectRatio > 1) {
                        watermarkWidth = maxSize;
                        watermarkHeight = maxSize / aspectRatio;
                    } else {
                        watermarkHeight = maxSize;
                        watermarkWidth = maxSize * aspectRatio;
                    }
                    
                    const selectedPosition = settings?.position ?? (document.querySelector('input[name="watermark-position"]:checked')?.value || 'bottom-right');
                    const { x, y } = calculateWatermarkPosition(selectedPosition, canvasWidth, canvasHeight, watermarkWidth, watermarkHeight, margin);
                    ctx.drawImage(img, x, y, watermarkWidth, watermarkHeight);
                    
                } else if (type === 'text') {
                    const text = settings?.text ?? watermarkText.value.trim();
                    const fontSizePxBase = settings?.fontSizePxBase ?? parseInt(watermarkFontSize?.value || '24', 10);
                    const fontSize = fontSizePxBase * (Math.min(canvasWidth, canvasHeight) / 500); // Scaled font size
                    const fontWeight = settings?.fontWeight ?? (watermarkFontWeight?.value || 'bold');
                    const textColor = settings?.textColor ?? (watermarkTextColor?.value || '#FFFFFF');
                    const strokeType = settings?.strokeType ?? (watermarkTextStroke?.value || 'none');
                    const selectedPosition = settings?.position ?? (document.querySelector('input[name="text-watermark-position"]:checked')?.value || 'bottom-right');
                    
                    // Set font
                    ctx.font = `${fontWeight} ${fontSize}px Arial, sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    
                    // Measure text
                    const textMetrics = ctx.measureText(text);
                    const textWidth = textMetrics.width;
                    const textHeight = fontSize;
                    
                    const { x, y } = calculateWatermarkPosition(selectedPosition, canvasWidth, canvasHeight, textWidth, textHeight, margin);
                    
                    // Apply text stroke if enabled
                    if (strokeType !== 'none') {
                        ctx.strokeStyle = strokeType === 'thick' ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.5)';
                        ctx.lineWidth = strokeType === 'thick' ? 3 : 1;
                        ctx.strokeText(text, x, y);
                    }
                    
                    // Fill text
                    ctx.fillStyle = textColor;
                    ctx.fillText(text, x, y);
                }
                
                ctx.restore();
            };

            // Helper function to calculate watermark position
            const calculateWatermarkPosition = (position, canvasWidth, canvasHeight, itemWidth, itemHeight, margin) => {
                let x, y;
                
                switch (position) {
                    case 'top-left':
                        x = margin;
                        y = margin;
                        break;
                    case 'top-center':
                        x = (canvasWidth - itemWidth) / 2;
                        y = margin;
                        break;
                    case 'top-right':
                        x = canvasWidth - itemWidth - margin;
                        y = margin;
                        break;
                    case 'center-left':
                        x = margin;
                        y = (canvasHeight - itemHeight) / 2;
                        break;
                    case 'center':
                        x = (canvasWidth - itemWidth) / 2;
                        y = (canvasHeight - itemHeight) / 2;
                        break;
                    case 'center-right':
                        x = canvasWidth - itemWidth - margin;
                        y = (canvasHeight - itemHeight) / 2;
                        break;
                    case 'bottom-left':
                        x = margin;
                        y = canvasHeight - itemHeight - margin;
                        break;
                    case 'bottom-center':
                        x = (canvasWidth - itemWidth) / 2;
                        y = canvasHeight - itemHeight - margin;
                        break;
                    case 'bottom-right':
                    default:
                        x = canvasWidth - itemWidth - margin;
                        y = canvasHeight - itemHeight - margin;
                        break;
                }
                
                return { x, y };
            };

            // --- Core Logic ---
            const handleFile = (file) => {
                // Validate file type and size
                const fileValidation = validateImageFile(file);
                if (!fileValidation.valid) {
                    showFieldError(fileInput, fileValidation.message);
                    return;
                }
                
                showFieldSuccess(fileInput);
                showLoading('Loading image...', true);
                showPreviewSkeleton();
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        updateProgress(30, 'Validating dimensions...');
                        // Validate image dimensions
                        const dimensionValidation = validateImageDimensions(img);
                        if (!dimensionValidation.valid) {
                            showFieldError(fileInput, dimensionValidation.message);
                            hideLoading();
                            return;
                        }
                        updateProgress(60, 'Preparing preview...');
                        originalImage = { element: img, width: img.width, height: img.height, src: e.target.result, name: file.name };
                        updateImageDetails();
                        previewImg.src = e.target.result;
                        const nameEl = document.getElementById('selected-filename-preview');
                        if (nameEl) nameEl.textContent = file.name || 'Selected image';
                        // Use requestIdleCallback for non-critical operations
                        if (window.requestIdleCallback) {
                            requestIdleCallback(() => populateColorPalette(img));
                        } else {
                            setTimeout(() => populateColorPalette(img), 0);
                        }
                        errorMessage.style.display = 'none';
                        uploadArea.style.display = 'none';
                        previewContainer.style.display = 'block';
                        resultContainer.style.display = 'none';
                        if (videoResultCard) videoResultCard.style.display = 'none';
                        videoBlob = null;
                        updateProgress(100, 'Ready');
                        hidePreviewSkeleton();
                        setTimeout(() => hideLoading(), 300);
                        updateQualityLabel();
                    };
                    img.onerror = () => { showError('Could not load the image.'); hidePreviewSkeleton(); hideLoading(); };
                    img.src = e.target.result;
                };
                reader.onerror = () => { showError('Error reading the file.'); hidePreviewSkeleton(); hideLoading(); };
                reader.readAsDataURL(file);
            };

            const updateImageDetails = () => {
                if (!originalImage) return;
                const { scaledWidth, scaledHeight, sliceCount, sliceWidth, sliceHeight } = calculateOptimalScaling(originalImage.width, originalImage.height, highResToggle?.checked || false);
                originalSizeText.textContent = `${originalImage.width}px × ${originalImage.height}px`;
                scaledSizeText.textContent = `${scaledWidth}px × ${scaledHeight}px`;
                sliceCountText.textContent = sliceCount;
                sliceResolutionText.textContent = `${sliceWidth}px × ${sliceHeight}px`;
            };

            const calculateOptimalScaling = (originalWidth, originalHeight, highResMode) => {
                let sliceHeight = highResMode ? originalHeight : STANDARD_HEIGHT;
                let sliceWidth = Math.round(sliceHeight * ASPECT_RATIO);
                const scaleFactor = sliceHeight / originalHeight;
                const baseScaledWidth = Math.round(originalWidth * scaleFactor);
                const fullSlices = Math.floor(baseScaledWidth / sliceWidth);
                const remainingWidth = baseScaledWidth - (fullSlices * sliceWidth);
                let finalSliceCount;
                if (fullSlices < MIN_SLICES) { finalSliceCount = MIN_SLICES; } 
                else if (remainingWidth > (sliceWidth / 2) && fullSlices < 10) { finalSliceCount = fullSlices + 1; } 
                else { finalSliceCount = Math.min(fullSlices, 10); }
                const finalScaledWidth = finalSliceCount * sliceWidth;
                const adjustedScaleFactor = finalScaledWidth / originalWidth;
                const finalScaledHeight = Math.round(originalHeight * adjustedScaleFactor);
                return { scaledWidth: finalScaledWidth, scaledHeight: finalScaledHeight, sliceCount: finalSliceCount, sliceWidth, sliceHeight: finalScaledHeight };
            };

            const processImage = () => {
                if (!originalImage) return;
                const { scaledWidth, scaledHeight, sliceCount, sliceWidth, sliceHeight } = calculateOptimalScaling(originalImage.width, originalImage.height, highResToggle?.checked || false);
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = scaledWidth;
                canvas.height = scaledHeight;
                ctx.drawImage(originalImage.element, 0, 0, scaledWidth, scaledHeight);
                slicedImages = [];
                for (let i = 0; i < sliceCount; i++) {
                    const sliceCanvas = document.createElement('canvas');
                    sliceCanvas.width = sliceWidth;
                    sliceCanvas.height = sliceHeight;
                    sliceCanvas.getContext('2d').drawImage(canvas, i * sliceWidth, 0, sliceWidth, scaledHeight, 0, 0, sliceWidth, sliceHeight);
                    slicedImages.push({ dataURL: sliceCanvas.toDataURL(EXPORT_TYPE), number: i + 1, width: sliceWidth, height: sliceHeight });
                }
                createFullViewImage(sliceWidth, sliceHeight);
                displayResults();
            };

            const processImageWithProgress = async () => {
                if (!originalImage) return;
                
                updateProgress(5, 'Analyzing image dimensions...');
                await new Promise(resolve => setTimeout(resolve, 150));
                
                updateProgress(12, 'Calculating optimal slice parameters...');
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const { scaledWidth, scaledHeight, sliceCount, sliceWidth, sliceHeight } = calculateOptimalScaling(
                    originalImage.width,
                    originalImage.height,
                    highResToggle?.checked || false
                );
                
                updateProgress(18, 'Optimizing for high resolution...');
                await new Promise(resolve => setTimeout(resolve, 100));
                
                updateProgress(25, 'Preparing rendering canvas...');
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = scaledWidth;
                canvas.height = scaledHeight;
                
                updateProgress(30, 'Rendering base image...');
                await new Promise(resolve => setTimeout(resolve, 100));
                ctx.drawImage(originalImage.element, 0, 0, scaledWidth, scaledHeight);
                
                updateProgress(35, 'Initializing slice generation...');
                await new Promise(resolve => setTimeout(resolve, 100));
                
                slicedImages = [];
                const hasWatermark = currentWatermarkType !== 'none';
                // Precompute watermark settings for this slicing session
                const wmSettingsSlices = collectWatermarkSettings();
                
                for (let i = 0; i < sliceCount; i++) {
                    const sliceCanvas = document.createElement('canvas');
                    const sliceCtx = sliceCanvas.getContext('2d');
                    sliceCanvas.width = sliceWidth;
                    sliceCanvas.height = sliceHeight;
                    
                    // Progress for image drawing
                    const baseProgress = 35 + (i / sliceCount) * 30;
                    updateProgress(baseProgress, `Rendering slice ${i + 1} of ${sliceCount}...`);
                    
                    sliceCtx.drawImage(canvas, i * sliceWidth, 0, sliceWidth, scaledHeight, 0, 0, sliceWidth, sliceHeight);
                    
                    // Apply watermark if enabled
                    if (hasWatermark) {
                        updateProgress(baseProgress + 2, `Adding watermark to slice ${i + 1}...`);
                        applyWatermark(sliceCanvas, sliceCtx, wmSettingsSlices);
                    }
                    
                    // Progress for conversion
                    updateProgress(baseProgress + 5, `Converting slice ${i + 1} to PNG...`);
                    
                    slicedImages.push({ 
                        dataURL: sliceCanvas.toDataURL(EXPORT_TYPE), 
                        number: i + 1, 
                        width: sliceWidth, 
                        height: sliceHeight 
                    });
                    
                    // Small delay for every few slices to allow UI update
                    if (i % 3 === 0) await new Promise(resolve => setTimeout(resolve, 30));
                }
                
                updateProgress(75, 'Preparing full view canvas...');
                await new Promise(resolve => setTimeout(resolve, 100));
                
                updateProgress(80, 'Rendering full panorama view...');
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Ensure full view is created after any async background operations complete
                await Promise.resolve(createFullViewImage(sliceWidth, sliceHeight));
                
                if (hasWatermark) {
                    updateProgress(90, 'Applying watermark to full view...');
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                updateProgress(95, 'Optimizing output quality...');
                await new Promise(resolve => setTimeout(resolve, 100));
                
                updateProgress(100, 'Completing processing...');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                hideLoading();
                showSuccessWithPulse('Slices generated successfully!');
                displayResults();
            };
            
            const updateFullViewPreview = () => {
                const { sliceWidth, sliceHeight } = calculateOptimalScaling(originalImage.width, originalImage.height, highResToggle?.checked || false);
                createFullViewImage(sliceWidth, sliceHeight);
                const fullViewElement = document.querySelector('.full-view-item img');
                if (fullViewElement) {
                    fullViewElement.src = fullViewImage.dataURL;
                }
            }

            const createFullViewImage = (sliceWidth, sliceHeight) => {
                if (!originalImage) return;
                const fullCanvas = document.createElement('canvas');
                const fullCtx = fullCanvas.getContext('2d');
                fullCanvas.width = sliceWidth;
                fullCanvas.height = sliceHeight;

                // Draw background
                const selectedBgType = document.querySelector('input[name="bg-type"]:checked')?.value || 'blur';
                if (selectedBgType === 'blur') {
                    // Fast separable blur on downscaled copy, then upscale
                    const radius = parseInt(blurIntensity?.value || '10', 10);
                    const downscalePct = Math.max(10, Math.min(100, parseInt(blurDownscale?.value || '35', 10)));
                    const scale = downscalePct / 100;
                    const smallW = Math.max(8, Math.round(sliceWidth * scale));
                    const smallH = Math.max(8, Math.round(sliceHeight * scale));
                    const tmp = document.createElement('canvas');
                    tmp.width = smallW;
                    tmp.height = smallH;
                    const tctx = tmp.getContext('2d');
                    tctx.drawImage(originalImage.element, 0, 0, smallW, smallH);
                    // Apply fast separable blur
                    stackBlurCanvasRGBA(tmp, 0, 0, smallW, smallH, Math.max(0, radius));
                    // Composite to full size
                    fullCtx.imageSmoothingEnabled = true;
                    fullCtx.imageSmoothingQuality = 'high';
                    fullCtx.drawImage(tmp, 0, 0, sliceWidth, sliceHeight);
                } else if (selectedBgType === 'gradient') {
                    const stops = Math.max(3, Math.min(5, parseInt(gradientStops?.value || '4', 10)));
                    const colors = extractPaletteKMeans(originalImage.element, stops);
                    // Synchronous Canvas gradients (linear/radial); angular approximated
                    renderGradientBackground(fullCtx, sliceWidth, sliceHeight, colors, gradientType?.value || 'radial', gradientBlend?.value || 'normal');
                } else {
                    fullCtx.fillStyle = bgColorPicker.value;
                    fullCtx.fillRect(0, 0, sliceWidth, sliceHeight);
                }

                // Draw centered foreground image
                const margin = Math.round(sliceWidth * 0.08);
                const availableWidth = sliceWidth - (margin * 2);
                const availableHeight = sliceHeight - (margin * 2);
                const originalAspectRatio = originalImage.width / originalImage.height;
                let scaledPanoWidth, scaledPanoHeight;
                if ((availableWidth / availableHeight) < originalAspectRatio) {
                    scaledPanoWidth = availableWidth;
                    scaledPanoHeight = scaledPanoWidth / originalAspectRatio;
                } else {
                    scaledPanoHeight = availableHeight;
                    scaledPanoWidth = scaledPanoHeight * originalAspectRatio;
                }
                const x = Math.round((sliceWidth - scaledPanoWidth) / 2);
                const y = Math.round((sliceHeight - scaledPanoHeight) / 2);
                // Composite foreground in normal mode to keep it sharp over blurred/gradient bg
                fullCtx.save();
                fullCtx.globalCompositeOperation = 'source-over';
                fullCtx.drawImage(originalImage.element, x, y, scaledPanoWidth, scaledPanoHeight);
                fullCtx.restore();
                
                // Apply watermark to full view
                // Apply watermark to full view using same settings pattern
                const wmSettingsFull = collectWatermarkSettings();
                applyWatermark(fullCanvas, fullCtx, wmSettingsFull);
                
                fullViewImage = { dataURL: fullCanvas.toDataURL(EXPORT_TYPE), width: sliceWidth, height: sliceHeight };
            };

            const displayResults = () => {
                slicesPreview.innerHTML = '';
                if (fullViewImage) slicesPreview.appendChild(createSliceElement(fullViewImage, true));
                slicedImages.forEach(slice => slicesPreview.appendChild(createSliceElement(slice, false)));
                
                // Add swipe functionality to results
                setupSwipeNavigation();
                
                resultContainer.style.display = 'block';
                window.scrollTo({ top: resultContainer.offsetTop - 20, behavior: 'smooth' });
                
                // Optional cleanup of ImageBitmap to avoid memory leaks
                try { if (sourceBitmap && typeof sourceBitmap.close === 'function') sourceBitmap.close(); } catch (_) {}
            };

            // --- Swipe Navigation ---
            const setupSwipeNavigation = () => {
                const preview = slicesPreview;
                if (!preview || window.innerWidth >= 768) return; // Only on mobile
                
                preview.style.position = 'relative';
                // Ensure horizontal scrolling works on mobile
                preview.style.display = 'flex';
                preview.style.flexWrap = 'nowrap';
                preview.style.overflowX = 'auto';
                preview.style.scrollSnapType = 'x mandatory';
                preview.querySelectorAll('.slice-item').forEach(el => {
                    el.style.flex = '0 0 auto';
                    el.style.scrollSnapAlign = 'start';
                });
                
                // Add swipe indicator
                const indicator = document.createElement('div');
                indicator.className = 'swipe-indicator';
                indicator.innerHTML = `
                    <svg data-lucide="hand" fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-4 h-4">
                        <path d="M8 13V7a2 2 0 1 1 4 0v6"/>
                        <path d="M12 13V5a2 2 0 1 1 4 0v8"/>
                        <path d="M16 13v-3a2 2 0 1 1 4 0v5a7 7 0 0 1-7 7h-1a7 7 0 0 1-7-7v-3"/>
                    </svg>
                    <span>Swipe to browse</span>
                `;
                preview.appendChild(indicator);
                
                let startX = 0;
                let scrollLeft = 0;
                let isDown = false;

                const onStart = (e) => {
                    isDown = true;
                    startX = (e.pageX || e.touches[0].pageX) - preview.offsetLeft;
                    scrollLeft = preview.scrollLeft;
                    preview.style.cursor = 'grabbing';
                    
                    // Haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate(10);
                    }
                };

                const onMove = (e) => {
                    if (!isDown) return;
                    e.preventDefault();
                    const x = (e.pageX || e.touches[0].pageX) - preview.offsetLeft;
                    const walk = (x - startX) * 2;
                    preview.scrollLeft = scrollLeft - walk;
                };

                const onEnd = () => {
                    isDown = false;
                    preview.style.cursor = 'grab';
                };

                preview.addEventListener('mousedown', onStart);
                preview.addEventListener('mousemove', onMove);
                preview.addEventListener('mouseup', onEnd);
                preview.addEventListener('mouseleave', onEnd);
                
                preview.addEventListener('touchstart', onStart, { passive: true });
                preview.addEventListener('touchmove', onMove, { passive: false });
                preview.addEventListener('touchend', onEnd);
                
                // Show indicator only if there is horizontal overflow
                if (preview.scrollWidth <= preview.clientWidth) {
                    indicator.style.display = 'none';
                } else {
                setTimeout(() => {
                    if (indicator) indicator.style.opacity = '0';
                }, 3000);
                }
            };

            // --- Video Generation ---
            const updateQualityLabel = () => {
                if (!videoQualityLabel || !videoQualityInput) return;
                const q = Math.max(10, Math.min(100, parseInt(videoQualityInput.value || '80', 10)));
                const dims = computeVideoViewport();
                const approxMbps = computeApproxBitrateMbps(q, parseInt(videoFpsInput?.value || '30', 10), dims.width, dims.height);
                videoQualityLabel.textContent = `≈ ${approxMbps.toFixed(1)} Mbps`;
                if (uiFormatLabel) {
                    const fmt = (videoFormatSelect?.value || 'webm').toLowerCase();
                    uiFormatLabel.textContent = fmt === 'mp4' ? 'MP4' : 'WebM';
                }
            };

            const updateEasingDescription = () => {
                if (!easingDescription || !videoEasingSelect) return;
                const easing = videoEasingSelect.value;
                const descriptions = {
                    'linear': 'Constant speed throughout',
                    'ease': 'Slow start, fast middle, slow end',
                    'ease-in': 'Slow start, gradually accelerates',
                    'ease-out': 'Fast start, gradually decelerates',
                    'ease-in-out': 'Slow start and end, fast middle',
                    'smooth': 'Very smooth acceleration and deceleration',
                    'bounce': 'Elastic bounce effect at direction changes'
                };
                easingDescription.textContent = descriptions[easing] || descriptions['linear'];
            };

            const computeVideoViewport = () => {
                if (!originalImage) return { width: Math.round(STANDARD_HEIGHT * ASPECT_RATIO), height: STANDARD_HEIGHT };
                const desiredHeight = (highResToggle?.checked ? originalImage.height : Math.min(STANDARD_HEIGHT, originalImage.height));
                let height = Math.max(1, Math.floor(desiredHeight));
                let width = Math.max(1, Math.floor(height * ASPECT_RATIO));
                if (width > originalImage.width) {
                    width = originalImage.width;
                    height = Math.floor(width / ASPECT_RATIO);
                }
                return { width, height };
            };

            const computeApproxBitrateMbps = (quality, fps, width, height) => {
                // Map quality 10..100 to base Mbps 1..12
                const minMbps = 1.0, maxMbps = 12.0;
                const base = minMbps + ((Math.max(10, Math.min(100, quality)) - 10) / 90) * (maxMbps - minMbps);
                // Scale for resolution and fps relative to 1080x1350 @ 30fps
                const baselinePixelsPerSec = 1080 * 1350 * 30;
                const pixelsPerSec = Math.max(1, width * height * Math.max(10, Math.min(60, fps)));
                const scaled = base * (pixelsPerSec / baselinePixelsPerSec);
                return Math.max(0.8, Math.min(25, scaled));
            };

            // Optional in-browser WebM -> MP4 via ffmpeg.wasm if available. Loaded lazily.
            let ffmpegLoading = null;
            let ffmpegModule = null;
            const ensureFfmpeg = async () => {
                if (ffmpegModule) return ffmpegModule;
                if (!ffmpegLoading) {
                    ffmpegLoading = (async () => {
                        // Load ffmpeg.wasm from CDN. Using v0.12+ API interface if available.
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.9/dist/ffmpeg.min.js';
                        document.head.appendChild(script);
                        await new Promise((res, rej) => { script.onload = res; script.onerror = rej; });
                        const { createFFmpeg, fetchFile } = window.FFmpeg || window.ffmpeg || {};
                        if (!createFFmpeg) throw new Error('ffmpeg.wasm not available');
                        const ffmpeg = createFFmpeg({ log: false });
                        await ffmpeg.load();
                        return { ffmpeg, fetchFile };
                    })();
                }
                ffmpegModule = await ffmpegLoading;
                return ffmpegModule;
            };

            const transcodeWebMToMp4 = async (webmBlob) => {
                try {
                    const { ffmpeg, fetchFile } = await ensureFfmpeg();
                    const inputName = 'input.webm';
                    const outputName = 'output.mp4';
                    ffmpeg.FS('writeFile', inputName, await fetchFile(webmBlob));
                    // Fast preset, good baseline compatibility
                    await ffmpeg.run('-i', inputName, '-movflags', 'faststart', '-c:v', 'libx264', '-preset', 'veryfast', '-pix_fmt', 'yuv420p', outputName);
                    const data = ffmpeg.FS('readFile', outputName);
                    ffmpeg.FS('unlink', inputName);
                    ffmpeg.FS('unlink', outputName);
                    return new Blob([data.buffer], { type: 'video/mp4' });
                } catch (e) {
                    console.error('ffmpeg transcode error:', e);
                    return null;
                }
            };

            // Easing functions for smooth animation
            const easingFunctions = {
                linear: (t) => t,
                ease: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
                'ease-in': (t) => t * t,
                'ease-out': (t) => t * (2 - t),
                // Smooth continuous back-and-forth (no jerk at midpoint)
                'ease-in-out': (t) => 0.5 - 0.5 * Math.cos(Math.PI * t), // cosine ease
                smooth: (t) => t * t * (3 - 2 * t), // smoothstep
                bounce: (t) => {
                    const n1 = 7.5625;
                    const d1 = 2.75;
                    if (t < 1 / d1) return n1 * t * t;
                    else if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
                    else if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
                    else return n1 * (t -= 2.625 / d1) * t + 0.984375;
                }
            };

            const chooseSupportedMimeType = (format) => {
                if ((format || 'webm') === 'mp4') {
                    const mp4Candidates = [
                        'video/mp4;codecs=h264',
                        'video/mp4'
                    ];
                    for (const type of mp4Candidates) {
                        if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(type)) return type;
                    }
                    // Fallback to webm if mp4 not supported
                }
                const webmCandidates = [
                    'video/webm;codecs=vp9',
                    'video/webm;codecs=vp8',
                    'video/webm'
                ];
                for (const type of webmCandidates) {
                    if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(type)) return type;
                }
                return 'video/webm';
            };

            const generatePanningVideo = async () => {
                if (!originalImage) throw new Error('No image');
                if (typeof MediaRecorder === 'undefined' || !HTMLCanvasElement.prototype.captureStream) {
                    throw new Error('MediaRecorder/canvas captureStream not supported');
                }

                const durationSec = Math.max(2, Math.min(120, parseFloat(videoDurationInput?.value || '10')));
                const fps = Math.max(10, Math.min(60, parseInt(videoFpsInput?.value || '30', 10)));
                const quality = Math.max(10, Math.min(100, parseInt(videoQualityInput?.value || '80', 10)));
                const easingType = videoEasingSelect?.value || 'linear';
                const easingFunc = easingFunctions[easingType] || easingFunctions.linear;

                const { width: viewportWidth, height: viewportHeight } = computeVideoViewport();
                // Precompute watermark settings once for the whole recording
                const wmSettings = collectWatermarkSettings();
                const canvas = document.createElement('canvas');
                canvas.width = viewportWidth;
                canvas.height = viewportHeight;
                const ctx = canvas.getContext('2d');
                
                // Performance optimizations
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                let sourceBitmap = null;
                try {
                    // Use createImageBitmap for better performance
                    sourceBitmap = await createImageBitmap(originalImage.element, {
                        resizeWidth: originalImage.width,
                        resizeHeight: originalImage.height,
                        resizeQuality: 'high'
                    });
                } catch (_) {
                    // Fallback: use the HTMLImageElement directly
                    sourceBitmap = originalImage.element;
                }
                const maxOffsetX = Math.max(0, sourceBitmap.width - viewportWidth);
                const centerOffsetY = Math.max(0, Math.floor((sourceBitmap.height - viewportHeight) / 2));

                const requestedFormat = (videoFormatSelect?.value || 'webm').toLowerCase();
                const mimeType = chooseSupportedMimeType(requestedFormat);
                const approxMbps = computeApproxBitrateMbps(quality, fps, viewportWidth, viewportHeight);
                const videoBitsPerSecond = Math.floor(approxMbps * 1_000_000);

                const stream = canvas.captureStream(fps);
                const recorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond });
                const chunks = [];
                recorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) chunks.push(e.data); };

                const startTime = performance.now();
                const endTime = startTime + durationSec * 1000;
                let animationFrameId = 0;
                let lastFrameTime = 0;
                const frameInterval = 1000 / fps;
                let ended = false;

                const drawFrame = (now) => {
                    // More precise frame timing for smoother animation
                    if (now - lastFrameTime < frameInterval - 2) {
                        animationFrameId = requestAnimationFrame(drawFrame);
                        return;
                    }
                    lastFrameTime = now;
                    
                    // Calculate progress from 0 to 1 over the full duration
                    const elapsed = now - startTime;
                    let t = Math.max(0, Math.min(1, elapsed / (durationSec * 1000)));
                    
                    // Use sinusoidal ping-pong to avoid harsh reversals
                    // phase goes 0->1->0 smoothly with continuous velocity
                    const phase = 0.5 * (1 - Math.cos(2 * Math.PI * t));
                    
                    // Use sub-pixel positioning for smoother movement
                    const offsetX = phase * maxOffsetX;
                    const sx = Math.max(0, Math.min(sourceBitmap.width - viewportWidth, offsetX));
                    
                    // Clear only the necessary area for better performance
                    ctx.clearRect(0, 0, viewportWidth, viewportHeight);
                    
                    // Use high-quality rendering
                    ctx.drawImage(
                        sourceBitmap,
                        sx, centerOffsetY, viewportWidth, viewportHeight,
                        0, 0, viewportWidth, viewportHeight
                    );

                // Apply watermark to video frame using precomputed settings
                applyWatermark(canvas, ctx, wmSettings);

                    if (now < endTime) {
                        animationFrameId = requestAnimationFrame(drawFrame);
                    } else if (!ended) {
                        ended = true;
                        // Stop the recorder on the next animation frame to ensure the last frame is encoded
                        requestAnimationFrame(() => { try { recorder.stop(); } catch (_) {} });
                    }
                };

                // Start recording and animation
                let stopResolve;
                const stopped = new Promise((resolve) => { stopResolve = resolve; });
                recorder.onstop = () => stopResolve();
                
                // Draw initial frame before starting recording
                const initialTime = performance.now();
                lastFrameTime = initialTime;
                ctx.clearRect(0, 0, viewportWidth, viewportHeight);
                ctx.drawImage(
                    sourceBitmap,
                    0, centerOffsetY, viewportWidth, viewportHeight,
                    0, 0, viewportWidth, viewportHeight
                );
                // Apply watermark to initial frame
                applyWatermark(canvas, ctx, wmSettings);
                
                recorder.start();
                // Small delay to ensure recording has started
                await new Promise(resolve => setTimeout(resolve, 50));
                
                animationFrameId = requestAnimationFrame(drawFrame);

                // Let RAF loop run and stop itself; wait for onstop
                await stopped;
                // Now stop tracks and free resources
                try { stream.getTracks().forEach(track => track.stop()); } catch(_) {}
                try { if (sourceBitmap && typeof sourceBitmap.close === 'function') sourceBitmap.close(); } catch(_) {}
                let blob = new Blob(chunks, { type: mimeType });
                const actualIsMp4 = mimeType.startsWith('video/mp4');
                if (requestedFormat === 'mp4' && !actualIsMp4) {
                    // Transcode WebM -> MP4 in-browser if possible
                    try {
                        const mp4Blob = await transcodeWebMToMp4(blob);
                        if (mp4Blob) blob = mp4Blob;
                        if (uiFormatLabel) uiFormatLabel.textContent = 'MP4';
                        currentVideoExt = 'mp4';
                    } catch (e) {
                        console.warn('Transcode to MP4 failed, staying on WebM:', e);
                        showError('Could not export MP4 in your browser. Exported WebM instead.');
                        if (uiFormatLabel) uiFormatLabel.textContent = 'WebM';
                        currentVideoExt = 'webm';
                    }
                } else {
                    if (uiFormatLabel) uiFormatLabel.textContent = actualIsMp4 ? 'MP4' : 'WebM';
                    currentVideoExt = actualIsMp4 ? 'mp4' : 'webm';
                }

                // Cleanup existing object URL if any
                if (panningVideo.src && panningVideo.src.startsWith('blob:')) {
                    try { URL.revokeObjectURL(panningVideo.src); } catch (_) {}
                }
                videoBlob = blob;
                const url = URL.createObjectURL(blob);
                panningVideo.src = url;
                panningVideo.load();
                if (videoResultCard) videoResultCard.style.display = 'block';
                resultContainer.style.display = 'block';
                window.scrollTo({ top: resultContainer.offsetTop - 20, behavior: 'smooth' });
            };

            // Initialize quality label and easing description
            updateQualityLabel();
            updateEasingDescription();
            // Ensure chip initial position
            try { document.querySelector('#video-quality')?.dispatchEvent(new Event('input')); } catch(_) {}

            // --- Liquid Glass Effects ---
            const initLiquidGlass = () => {
                const cards = document.querySelectorAll('.glass-card');
                
                cards.forEach(card => {
                    const sheen = card.querySelector('.glass-sheen');
                    if (!sheen) return;

                    const updateSheen = (e) => {
                        const rect = card.getBoundingClientRect();
                        const x = ((e.clientX || (rect.left + rect.width / 2)) - rect.left) / rect.width * 100;
                        const y = ((e.clientY || (rect.top + rect.height / 2)) - rect.top) / rect.height * 100;
                        card.style.setProperty('--mx', x + '%');
                        card.style.setProperty('--my', y + '%');
                    };

                    // Mouse tracking
                    card.addEventListener('pointermove', updateSheen);
                    card.addEventListener('pointerenter', updateSheen);
                    card.addEventListener('pointerleave', () => {
                        card.style.setProperty('--mx', '50%');
                        card.style.setProperty('--my', '50%');
                    });

                    // Touch support for mobile
                    card.addEventListener('touchmove', (e) => {
                        if (e.touches.length > 0) {
                            updateSheen(e.touches[0]);
                        }
                    }, { passive: true });
                });
            };

            // Initialize liquid glass effects
            initLiquidGlass();

            // --- Interactive Aurora Background ---
            const initAuroraEffect = () => {
                let mouseX = 0.5;
                let mouseY = 0.5;
                
                // Smooth mouse tracking
                document.addEventListener('mousemove', (e) => {
                    mouseX = e.clientX / window.innerWidth;
                    mouseY = e.clientY / window.innerHeight;
                });

                // Aurora animation loop
                const updateAurora = () => {
                    const time = Date.now() * 0.001; // Convert to seconds
                    
                    // Main background gradients - subtle mouse following
                    const aurora1X = 20 + (mouseX - 0.5) * 15 + Math.sin(time * 0.3) * 8;
                    const aurora1Y = 15 + (mouseY - 0.5) * 10 + Math.cos(time * 0.4) * 6;
                    const aurora1Opacity = 0.15 + (mouseX * 0.05) + Math.sin(time * 0.5) * 0.03;
                    
                    const aurora2X = 80 + (mouseX - 0.5) * 12 + Math.cos(time * 0.35) * 10;
                    const aurora2Y = 25 + (mouseY - 0.5) * 8 + Math.sin(time * 0.45) * 7;
                    const aurora2Opacity = 0.12 + (mouseY * 0.04) + Math.cos(time * 0.6) * 0.025;
                    
                    const aurora3X = 60 + (mouseX - 0.5) * 10 + Math.sin(time * 0.25) * 12;
                    const aurora3Y = 85 + (mouseY - 0.5) * 6 + Math.cos(time * 0.3) * 8;
                    const aurora3Opacity = 0.08 + (mouseX * mouseY * 0.04) + Math.sin(time * 0.4) * 0.02;
                    
                    const aurora4X = 10 + (mouseX - 0.5) * 18 + Math.cos(time * 0.2) * 15;
                    const aurora4Y = 90 + (mouseY - 0.5) * 12 + Math.sin(time * 0.35) * 9;
                    const aurora4Opacity = 0.1 + ((1 - mouseY) * 0.05) + Math.cos(time * 0.7) * 0.03;
                    
                    // Apply to CSS variables
                    document.documentElement.style.setProperty('--aurora-1-x', `${Math.max(0, Math.min(100, aurora1X))}%`);
                    document.documentElement.style.setProperty('--aurora-1-y', `${Math.max(0, Math.min(100, aurora1Y))}%`);
                    document.documentElement.style.setProperty('--aurora-1-opacity', Math.max(0, Math.min(0.25, aurora1Opacity)));
                    
                    document.documentElement.style.setProperty('--aurora-2-x', `${Math.max(0, Math.min(100, aurora2X))}%`);
                    document.documentElement.style.setProperty('--aurora-2-y', `${Math.max(0, Math.min(100, aurora2Y))}%`);
                    document.documentElement.style.setProperty('--aurora-2-opacity', Math.max(0, Math.min(0.2, aurora2Opacity)));
                    
                    document.documentElement.style.setProperty('--aurora-3-x', `${Math.max(0, Math.min(100, aurora3X))}%`);
                    document.documentElement.style.setProperty('--aurora-3-y', `${Math.max(0, Math.min(100, aurora3Y))}%`);
                    document.documentElement.style.setProperty('--aurora-3-opacity', Math.max(0, Math.min(0.15, aurora3Opacity)));
                    
                    document.documentElement.style.setProperty('--aurora-4-x', `${Math.max(0, Math.min(100, aurora4X))}%`);
                    document.documentElement.style.setProperty('--aurora-4-y', `${Math.max(0, Math.min(100, aurora4Y))}%`);
                    document.documentElement.style.setProperty('--aurora-4-opacity', Math.max(0, Math.min(0.18, aurora4Opacity)));
                    
                    // Floating orbs - more responsive to mouse
                    const orb1X = 25 + (mouseX - 0.5) * 30 + Math.sin(time * 0.4) * 15;
                    const orb1Y = 25 + (mouseY - 0.5) * 25 + Math.cos(time * 0.5) * 12;
                    
                    const orb2X = 75 + (mouseX - 0.5) * -25 + Math.cos(time * 0.3) * 18;
                    const orb2Y = 75 + (mouseY - 0.5) * -20 + Math.sin(time * 0.6) * 10;
                    
                    const orb3X = 50 + (mouseX - 0.5) * 20 + Math.sin(time * 0.7) * 8;
                    const orb3Y = 50 + (mouseY - 0.5) * 15 + Math.cos(time * 0.4) * 6;
                    
                    document.documentElement.style.setProperty('--orb-1-x', `${Math.max(5, Math.min(95, orb1X))}%`);
                    document.documentElement.style.setProperty('--orb-1-y', `${Math.max(5, Math.min(95, orb1Y))}%`);
                    
                    document.documentElement.style.setProperty('--orb-2-x', `${Math.max(5, Math.min(95, orb2X))}%`);
                    document.documentElement.style.setProperty('--orb-2-y', `${Math.max(5, Math.min(95, orb2Y))}%`);
                    
                    document.documentElement.style.setProperty('--orb-3-x', `${Math.max(5, Math.min(95, orb3X))}%`);
                    document.documentElement.style.setProperty('--orb-3-y', `${Math.max(5, Math.min(95, orb3Y))}%`);
                    
                    requestAnimationFrame(updateAurora);
                };
                
                // Start the animation
                updateAurora();
            };

            // Initialize aurora effect
            initAuroraEffect();

            // --- Mobile Bottom Sheet Management ---
            const mobileFab = document.getElementById('mobile-fab');
            const bottomSheetHandle = document.getElementById('bottom-sheet-handle');
            let isBottomSheetOpen = false;

            // Mobile bottom sheet content containers
            const mobileSlicingContent = document.getElementById('mobile-slicing-content');
            const mobileBackgroundContent = document.getElementById('mobile-background-content');
            const mobileVideoContent = document.getElementById('mobile-video-content');

            const toggleBottomSheet = () => {
                isBottomSheetOpen = !isBottomSheetOpen;
                
                if (isBottomSheetOpen) {
                    populateBottomSheetContent();
                    bottomSheet.classList.add('open');
                    bottomSheetBackdrop.classList.add('open');
                    mobileFab.classList.add('open');
                    document.body.style.overflow = 'hidden';
                } else {
                    bottomSheet.classList.remove('open');
                    bottomSheetBackdrop.classList.remove('open');
                    mobileFab.classList.remove('open');
                    document.body.style.overflow = '';
                    // Move content back to desktop cards
                    try {
                        const slicingNode = mobileSlicingContent?.firstElementChild;
                        if (slicingNode && controls) {
                            const dest = controls.querySelector('.p-6') || controls;
                            dest.appendChild(slicingNode);
                        }
                        const bgNode = mobileBackgroundContent?.firstElementChild;
                        if (bgNode && fullViewSettings) {
                            const dest = fullViewSettings.querySelector('#full-view-content') || fullViewSettings;
                            dest.appendChild(bgNode);
                        }
                        const videoNode = mobileVideoContent?.firstElementChild;
                        if (videoNode && videoSettings) {
                            const dest = videoSettings.querySelector('#video-content') || videoSettings;
                            dest.appendChild(videoNode);
                        }
                        lucide.createIcons();
                    } catch (_) {}
                }

                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            };

            const populateBottomSheetContent = () => {
                // Move live nodes into the sheet instead of cloning
                if (mobileSlicingContent && controls) {
                    const src = controls.querySelector('.p-6');
                    if (src) {
                        mobileSlicingContent.innerHTML = '';
                        mobileSlicingContent.appendChild(src);
                    }
                }
                if (mobileBackgroundContent && fullViewSettings) {
                    const src = fullViewSettings.querySelector('#full-view-content .p-6');
                    if (src) {
                        mobileBackgroundContent.innerHTML = '';
                        mobileBackgroundContent.appendChild(src);
                    }
                }
                if (mobileVideoContent && videoSettings) {
                    const src = videoSettings.querySelector('#video-content .p-6');
                    if (src) {
                        mobileVideoContent.innerHTML = '';
                        mobileVideoContent.appendChild(src);
                    }
                }
                try { lucide.createIcons(); } catch(_) {}
            };

            // Event listeners for bottom sheet
            if (mobileFab) {
                mobileFab.addEventListener('click', toggleBottomSheet);
                mobileFab.addEventListener('touchstart', () => mobileFab.classList.add('active'), { passive: true });
                mobileFab.addEventListener('touchend', () => mobileFab.classList.remove('active'));
            }

            if (bottomSheetBackdrop) {
                bottomSheetBackdrop.addEventListener('click', () => {
                    if (isBottomSheetOpen) toggleBottomSheet();
                });
            }

            if (bottomSheetHandle) {
                bottomSheetHandle.addEventListener('click', toggleBottomSheet);
            }

            // Close bottom sheet on escape key
            document.addEventListener('keydown', (e) => {
                const tag = (e.target && e.target.tagName || '').toLowerCase();
                const typing = tag === 'input' || tag === 'textarea' || e.target?.isContentEditable;
                // Global shortcuts (ignored while typing)
                if (!typing) {
                    if (e.key === '?') { e.preventDefault(); openShortcuts(); }
                    if (e.key === 'u' || e.key === 'U') { e.preventDefault(); fileInput?.click(); }
                    if ((e.key === 'g' || e.key === 'G') && processBtn) { e.preventDefault(); processBtn.click(); }
                    if ((e.key === 'v' || e.key === 'V') && generateVideoBtn) { e.preventDefault(); generateVideoBtn.click(); }
                    if ((e.key === 'f' || e.key === 'F') && typeof toggleBottomSheet === 'function') { e.preventDefault(); toggleBottomSheet(); }
                }
                // Escape handling
                if (e.key === 'Escape') {
                    if (shortcutsModal?.classList.contains('open')) { e.preventDefault(); closeShortcuts(); return; }
                    if (isBottomSheetOpen) { e.preventDefault(); toggleBottomSheet(); }
                }
            });

            // --- Lightbox Functionality ---
            const lightbox = document.getElementById('lightbox');
            const lightboxImage = document.getElementById('lightbox-image');
            const lightboxTitle = document.getElementById('lightbox-title');
            const lightboxResolution = document.getElementById('lightbox-resolution');
            const lightboxDownload = document.getElementById('lightbox-download');
            const lightboxPrev = document.getElementById('lightbox-prev');
            const lightboxNext = document.getElementById('lightbox-next');
            const lightboxClose = document.getElementById('lightbox-close');

            let currentLightboxImages = [];
            let currentLightboxIndex = 0;
            let isLightboxOpen = false;

            const openLightbox = (images, index = 0) => {
                currentLightboxImages = images;
                currentLightboxIndex = index;
                isLightboxOpen = true;
                
                updateLightboxContent();
                lightbox.classList.add('open');
                // Subtle zoom-in effect for image on open
                lightboxImage.style.transform = 'scale(0.98)';
                requestAnimationFrame(() => {
                    lightboxImage.style.transition = 'transform 220ms ease';
                    lightboxImage.style.transform = 'scale(1)';
                    setTimeout(() => { lightboxImage.style.transition = ''; }, 250);
                });
                document.body.style.overflow = 'hidden';
                
                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            };

            const closeLightbox = () => {
                isLightboxOpen = false;
                lightbox.classList.remove('open');
                document.body.style.overflow = '';
                
                // Clear image after animation
                setTimeout(() => {
                    lightboxImage.src = '';
                }, 300);
            };

            const updateLightboxContent = () => {
                const currentImage = currentLightboxImages[currentLightboxIndex];
                if (!currentImage) return;

                // Update image with a quick crossfade
                lightboxImage.style.opacity = '0';
                setTimeout(() => {
                lightboxImage.src = currentImage.dataURL;
                    requestAnimationFrame(() => {
                        lightboxImage.style.transition = 'opacity 180ms ease';
                        lightboxImage.style.opacity = '1';
                        setTimeout(() => { lightboxImage.style.transition = ''; }, 200);
                    });
                }, 30);
                
                // Update info
                lightboxTitle.textContent = currentImage.isFullView ? 'Full View' : `Slice ${currentImage.number}`;
                lightboxResolution.textContent = `${currentImage.width}×${currentImage.height}`;
                
                // Update download
                const filename = currentImage.isFullView 
                    ? `${originalImage?.name?.split('.').slice(0, -1).join('.') || 'pano'}_full_view.png`
                    : `${originalImage?.name?.split('.').slice(0, -1).join('.') || 'pano'}_${String(currentImage.number).padStart(2, '0')}.png`;
                
                lightboxDownload.href = currentImage.dataURL;
                lightboxDownload.download = filename;
                
                // Update navigation visibility
                lightboxPrev.style.display = currentLightboxImages.length > 1 ? 'flex' : 'none';
                lightboxNext.style.display = currentLightboxImages.length > 1 ? 'flex' : 'none';
                
                // Update navigation state
                lightboxPrev.style.opacity = currentLightboxIndex > 0 ? '1' : '0.5';
                lightboxNext.style.opacity = currentLightboxIndex < currentLightboxImages.length - 1 ? '1' : '0.5';
            };

            const navigateLightbox = (direction) => {
                if (direction === 'prev' && currentLightboxIndex > 0) {
                    currentLightboxIndex--;
                    updateLightboxContent();
                } else if (direction === 'next' && currentLightboxIndex < currentLightboxImages.length - 1) {
                    currentLightboxIndex++;
                    updateLightboxContent();
                }
                
                // Haptic feedback for navigation
                if (navigator.vibrate) {
                    navigator.vibrate(25);
                }
            };

            // Lightbox event listeners
            if (lightboxClose) {
                lightboxClose.addEventListener('click', closeLightbox);
            }

            if (lightboxPrev) {
                lightboxPrev.addEventListener('click', () => navigateLightbox('prev'));
            }

            if (lightboxNext) {
                lightboxNext.addEventListener('click', () => navigateLightbox('next'));
            }

            // Click outside to close
            if (lightbox) {
                lightbox.addEventListener('click', (e) => {
                    if (e.target === lightbox) {
                        closeLightbox();
                    }
                });
            }

            // Keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (!isLightboxOpen) return;
                
                switch(e.key) {
                    case 'Escape':
                        closeLightbox();
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        navigateLightbox('prev');
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        navigateLightbox('next');
                        break;
                }
            });

            const createSliceElement = (sliceData, isFullView) => {
                const item = document.createElement('div');
                item.className = 'slice-item';
                if (isFullView) item.classList.add('full-view-item');
                
                const img = document.createElement('img');
                img.src = sliceData.dataURL;
                img.alt = isFullView ? 'Full Panorama View' : `Slice ${sliceData.number}`;
                
                const resolution = document.createElement('div');
                resolution.className = 'resolution';
                resolution.textContent = `${sliceData.width}×${sliceData.height}`;
                
                item.appendChild(img);
                item.appendChild(resolution);
                
                if (isFullView) {
                    const label = document.createElement('div');
                    label.className = 'slice-label';
                    label.textContent = 'Full View';
                    item.appendChild(label);
                } else {
                    const number = document.createElement('div');
                    number.className = 'slice-number';
                    number.textContent = sliceData.number;
                    item.appendChild(number);
                }

                // Add copy to clipboard button
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.setAttribute('aria-label', 'Copy to clipboard');
                copyButton.innerHTML = `
                    <svg data-lucide="copy" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect>
                        <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path>
                    </svg>
                `;
                
                copyButton.addEventListener('click', async (e) => {
                    e.stopPropagation(); // Prevent lightbox from opening
                    await copyImageToClipboard(sliceData.dataURL, copyButton, isFullView);
                });
                
                item.appendChild(copyButton);

                // Add lightbox functionality to the image itself
                item.style.cursor = 'pointer';
                
                // Make slice items focusable for keyboard navigation
                item.setAttribute('tabindex', '0');
                item.setAttribute('role', 'button');
                item.setAttribute('aria-label', isFullView ? 'View full panorama' : `View slice ${sliceData.number}`);

                // Add click handler to img element specifically
                const openLightboxHandler = () => {
                    // Prepare images array with full view and slices
                    const allImages = [];
                    
                    // Add full view if it exists
                    if (fullViewImage) {
                        allImages.push({
                            ...fullViewImage,
                            isFullView: true
                        });
                    }
                    
                    // Add all slices
                    slicedImages.forEach(slice => {
                        allImages.push({
                            ...slice,
                            isFullView: false
                        });
                    });
                    
                    // Find the index of the clicked image
                    let clickedIndex = 0;
                    if (isFullView) {
                        clickedIndex = 0; // Full view is always first
                    } else {
                        // Find the slice index (accounting for full view offset)
                        clickedIndex = allImages.findIndex(img => 
                            !img.isFullView && img.number === sliceData.number
                        );
                    }
                    
                    openLightbox(allImages, clickedIndex);
                };

                // Add click and keyboard event handlers
                img.addEventListener('click', openLightboxHandler);
                
                // Keyboard navigation support
                item.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        openLightboxHandler();
                    }
                });
                
                return item;
            };
            
            const populateColorPalette = (imgElement) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const size = 50; // Sample size
                canvas.width = size;
                canvas.height = size;
                ctx.drawImage(imgElement, 0, 0, size, size);
                const data = ctx.getImageData(0, 0, size, size).data;
                const colorCounts = {};
                for (let i = 0; i < data.length; i += 4 * 5) { // Sample every 5th pixel
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const key = `${r},${g},${b}`;
                    colorCounts[key] = (colorCounts[key] || 0) + 1;
                }
                const sortedColors = Object.keys(colorCounts).sort((a, b) => colorCounts[b] - colorCounts[a]);
                colorPalette.innerHTML = '';
                sortedColors.slice(0, 6).forEach(colorKey => {
                    const [r, g, b] = colorKey.split(',');
                    const hex = `#${(+r).toString(16).padStart(2, '0')}${(+g).toString(16).padStart(2, '0')}${(+b).toString(16).padStart(2, '0')}`;
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = hex;
                    swatch.addEventListener('click', () => {
                        bgColorPicker.value = hex;
                        updateFullViewPreview();
                    });
                    colorPalette.appendChild(swatch);
                });
            };

            // --- Fast Separable Blur (StackBlur) ---
            // Minimal embedded StackBlur based on Mario Klingemann's algorithm (public domain-like)
            // Optimized for RGBA canvas
            const stackBlurCanvasRGBA = (canvas, top_x, top_y, width, height, radius) => {
                if (isNaN(radius) || radius < 1) return;
                const context = canvas.getContext('2d');
                const imageData = context.getImageData(top_x, top_y, width, height);
                const pixels = imageData.data;
                const div = radius + radius + 1;

                const r = new Uint32Array(width * height);
                const g = new Uint32Array(width * height);
                const b = new Uint32Array(width * height);
                const a = new Uint32Array(width * height);

                // Horizontal pass
                for (let y = 0; y < height; y++) {
                    let sumR = 0, sumG = 0, sumB = 0, sumA = 0;
                    for (let i = -radius; i <= radius; i++) {
                        const x = Math.min(width - 1, Math.max(0, i));
                        const idx = (y * width + x) << 2;
                        sumR += pixels[idx];
                        sumG += pixels[idx + 1];
                        sumB += pixels[idx + 2];
                        sumA += pixels[idx + 3];
                    }
                    for (let x = 0; x < width; x++) {
                        const outIndex = y * width + x;
                        r[outIndex] = sumR;
                        g[outIndex] = sumG;
                        b[outIndex] = sumB;
                        a[outIndex] = sumA;
                        const i1 = x - radius;
                        const i2 = x + radius + 1;
                        const idx1 = (y * width + Math.max(0, i1)) << 2;
                        const idx2 = (y * width + Math.min(width - 1, i2)) << 2;
                        sumR += pixels[idx2] - pixels[idx1];
                        sumG += pixels[idx2 + 1] - pixels[idx1 + 1];
                        sumB += pixels[idx2 + 2] - pixels[idx1 + 2];
                        sumA += pixels[idx2 + 3] - pixels[idx1 + 3];
                    }
                }

                // Vertical pass
                for (let x = 0; x < width; x++) {
                    let sumR = 0, sumG = 0, sumB = 0, sumA = 0;
                    for (let i = -radius; i <= radius; i++) {
                        const y = Math.min(height - 1, Math.max(0, i));
                        const idx = (y * width + x);
                        sumR += r[idx];
                        sumG += g[idx];
                        sumB += b[idx];
                        sumA += a[idx];
                    }
                    for (let y = 0; y < height; y++) {
                        const outIndex = (y * width + x) << 2;
                        const count = div * div;
                        pixels[outIndex] = Math.max(0, Math.min(255, (sumR / count) | 0));
                        pixels[outIndex + 1] = Math.max(0, Math.min(255, (sumG / count) | 0));
                        pixels[outIndex + 2] = Math.max(0, Math.min(255, (sumB / count) | 0));
                        pixels[outIndex + 3] = Math.max(0, Math.min(255, (sumA / count) | 0));
                        const i1 = y - radius;
                        const i2 = y + radius + 1;
                        const idx1 = Math.max(0, i1) * width + x;
                        const idx2 = Math.min(height - 1, i2) * width + x;
                        sumR += r[idx2] - r[idx1];
                        sumG += g[idx2] - g[idx1];
                        sumB += b[idx2] - b[idx1];
                        sumA += a[idx2] - a[idx1];
                    }
                }

                context.putImageData(imageData, top_x, top_y);
            };

            // --- K-means Palette Extraction ---
            const extractPaletteKMeans = (imgElement, k = 4) => {
                const size = 80;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = size;
                canvas.height = size;
                ctx.drawImage(imgElement, 0, 0, size, size);
                const { data } = ctx.getImageData(0, 0, size, size);
                const pixels = [];
                for (let i = 0; i < data.length; i += 4 * 3) { // sample every 3rd pixel
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    const a = data[i + 3];
                    if (a < 20) continue; // skip near-transparent
                    pixels.push([r, g, b]);
                }
                if (pixels.length === 0) return ['#0f172a', '#1e293b', '#334155', '#475569'];

                // Initialize centroids randomly
                const centroids = [];
                for (let i = 0; i < k; i++) {
                    const p = pixels[(Math.random() * pixels.length) | 0];
                    centroids.push(p.slice());
                }

                const maxIters = 12;
                for (let iter = 0; iter < maxIters; iter++) {
                    const groups = Array.from({ length: k }, () => []);
                    for (const p of pixels) {
                        let best = 0, bestD = Infinity;
                        for (let c = 0; c < k; c++) {
                            const cc = centroids[c];
                            const d = (p[0] - cc[0]) ** 2 + (p[1] - cc[1]) ** 2 + (p[2] - cc[2]) ** 2;
                            if (d < bestD) { bestD = d; best = c; }
                        }
                        groups[best].push(p);
                    }
                    for (let c = 0; c < k; c++) {
                        const group = groups[c];
                        if (group.length === 0) continue;
                        let sr = 0, sg = 0, sb = 0;
                        for (const p of group) { sr += p[0]; sg += p[1]; sb += p[2]; }
                        centroids[c] = [sr / group.length, sg / group.length, sb / group.length];
                    }
                }

                // Convert to hex and sort by perceived luminance
                const toHex = (r, g, b) => `#${Math.round(r).toString(16).padStart(2, '0')}${Math.round(g).toString(16).padStart(2, '0')}${Math.round(b).toString(16).padStart(2, '0')}`;
                const hexes = centroids.map(([r, g, b]) => toHex(r, g, b));
                const lum = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
                };
                return hexes.sort((a, b) => lum(a) - lum(b));
            };

            const updateGradientPreview = (colors) => {
                if (!gradientPreview) return;
                const type = gradientType?.value || 'radial';
                lastGradientPalette = colors && colors.length ? colors : lastGradientPalette;
                gradientPreview.style.background = buildGradientCSS(lastGradientPalette, type);
                gradientPreview.style.mixBlendMode = gradientBlend?.value || 'normal';
                // Populate preset palette swatches for quick selection, emphasizing an 8px spacing rhythm
                const holder = document.getElementById('color-palette');
                if (holder && holder.children.length === 0 && lastGradientPalette.length) {
                    const presets = [
                        ['#0ea5e9', '#22c55e', '#f59e0b'],
                        ['#8b5cf6', '#06b6d4', '#f43f5e'],
                        ['#111827', '#374151', '#60a5fa'],
                        ['#111827', '#1f2937', '#10b981']
                    ];
                    presets.forEach((palette, idx) => {
                        const sw = document.createElement('div');
                        sw.className = 'flex items-center gap-2 mr-2';
                        sw.setAttribute('role', 'button');
                        sw.setAttribute('tabindex', '0');
                        sw.style.minHeight = '44px';
                        palette.forEach(c => {
                            const dot = document.createElement('div');
                            dot.className = 'color-swatch';
                            dot.style.backgroundColor = c;
                            sw.appendChild(dot);
                        });
                        sw.addEventListener('click', () => {
                            lastGradientPalette = palette;
                            updateGradientPreview(lastGradientPalette);
                            if (originalImage) updateFullViewPreview();
                        });
                        holder.appendChild(sw);
                    });
                }
            };

            const buildGradientCSS = (colors, type = 'radial') => {
                const stops = colors.map((c, i) => `${c} ${(i / (colors.length - 1)) * 100}%`).join(', ');
                if (type === 'angular') return `conic-gradient(from 220deg, ${stops})`;
                if (type === 'linear') return `linear-gradient(135deg, ${stops})`;
                return `radial-gradient(circle at 30% 30%, ${stops})`;
            };

            const renderGradientBackground = (ctx, w, h, colors, type = 'radial', blend = 'normal') => {
                // Synchronous rendering using CanvasGradient for linear/radial.
                // For angular, approximate by rotating linear gradients.
                ctx.save();
                ctx.globalCompositeOperation = blend || 'normal';
                if (type === 'linear') {
                    const grad = ctx.createLinearGradient(0, 0, w, h);
                    colors.forEach((c, i) => grad.addColorStop(i / (colors.length - 1), c));
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);
                } else if (type === 'radial') {
                    const cx = w * 0.5, cy = h * 0.5, r = Math.hypot(w, h) * 0.6;
                    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
                    colors.forEach((c, i) => grad.addColorStop(i / (colors.length - 1), c));
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);
                } else {
                    // Angular approximation: draw multiple rotated linear bands
                    const steps = Math.max(24, colors.length * 8);
                    for (let i = 0; i < steps; i++) {
                        const t = i / (steps - 1);
                        // Interpolate color across stops
                        const idx = t * (colors.length - 1);
                        const i0 = Math.floor(idx), i1 = Math.min(colors.length - 1, i0 + 1);
                        const localT = idx - i0;
                        const c0 = colors[i0], c1 = colors[i1];
                        ctx.save();
                        ctx.translate(w / 2, h / 2);
                        ctx.rotate(t * Math.PI * 2);
                        const grad = ctx.createLinearGradient(0, -Math.max(w, h), 0, Math.max(w, h));
                        grad.addColorStop(0, c0);
                        grad.addColorStop(1, c1);
                        ctx.fillStyle = grad;
                        ctx.fillRect(-w, -h, w * 2, h * 2);
                        ctx.restore();
                    }
                }
                ctx.restore();
            };

            const downloadZip = async () => {
                if (slicedImages.length === 0 && !fullViewImage) return;
                const zip = new JSZip();
                const baseName = originalImage.name.split('.').slice(0, -1).join('.') || 'pano-images';
                const folder = zip.folder(baseName);
                if (fullViewImage) folder.file(`${baseName}_full_view.png`, fullViewImage.dataURL.split(',')[1], { base64: true });
                slicedImages.forEach(slice => folder.file(`${baseName}_${String(slice.number).padStart(2, '0')}.png`, slice.dataURL.split(',')[1], { base64: true }));
                if (videoBlob) {
                    const ext = currentVideoExt || (videoBlob.type && videoBlob.type.indexOf('mp4') !== -1 ? 'mp4' : 'webm');
                    folder.file(`${baseName}_panning.${ext}`, videoBlob);
                }
                const content = await zip.generateAsync({ type: 'blob' });
                saveAs(content, `${baseName}.zip`);
            };

            // --- Clipboard Paste Support ---
            document.addEventListener('paste', (e) => {
                // Do not intercept when user is typing in inputs/textareas/contenteditable
                const inEditable = e.target && (e.target.closest('input, textarea, [contenteditable="true"]'));
                if (inEditable) return;
                if (!e.clipboardData || !e.clipboardData.items) return;
                // Find image file in clipboard items
                const file = [...e.clipboardData.items]
                    .find(item => item.type.startsWith('image/'))
                    ?.getAsFile();
                
                if (file) {
                    // Prevent default paste behavior
                    e.preventDefault();
                    
                    // Show upload preview and handle the file
                    showUploadPreview(file);
                    handleFile(file);
                    
                    // Provide visual feedback
                    uploadArea.scrollIntoView({ behavior: 'smooth' });
                    
                    // Haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate([50, 100, 50]);
                    }
                    
                    // Show success message briefly
                    const pasteMessage = document.createElement('div');
                    pasteMessage.textContent = 'Image pasted from clipboard!';
                    pasteMessage.className = 'fixed top-4 right-4 bg-emerald-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 opacity-0 transition-opacity duration-300';
                    document.body.appendChild(pasteMessage);
                    
                    // Animate in
                    setTimeout(() => {
                        pasteMessage.style.opacity = '1';
                    }, 10);
                    
                    // Remove after delay
                    setTimeout(() => {
                        pasteMessage.style.opacity = '0';
                        setTimeout(() => {
                            document.body.removeChild(pasteMessage);
                        }, 300);
                    }, 2000);
                }
            });
        });
    </script>
</body>
</html>
